// @generated by protoc-gen-es v1.3.3 with parameter "target=ts"
// @generated from file ethermint/evm/v1/tx.proto (package ethermint.evm.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Any, Message, proto3, protoInt64 } from "@bufbuild/protobuf";
import { AccessTuple, Log, Params } from "./evm_pb.js";

/**
 * MsgEthereumTx encapsulates an Ethereum transaction as an SDK message.
 *
 * @generated from message ethermint.evm.v1.MsgEthereumTx
 */
export class MsgEthereumTx extends Message<MsgEthereumTx> {
  /**
   * data is inner transaction data of the Ethereum transaction
   *
   * @generated from field: google.protobuf.Any data = 1;
   */
  data?: Any;

  /**
   * size is the encoded storage size of the transaction (DEPRECATED)
   *
   * @generated from field: double size = 2;
   */
  size = 0;

  /**
   * hash of the transaction in hex format
   *
   * @generated from field: string hash = 3;
   */
  hash = "";

  /**
   * from is the ethereum signer address in hex format. This address value is
   * checked against the address derived from the signature (V, R, S) using the
   * secp256k1 elliptic curve
   *
   * @generated from field: string from = 4;
   */
  from = "";

  constructor(data?: PartialMessage<MsgEthereumTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.MsgEthereumTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Any },
    { no: 2, name: "size", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "from", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgEthereumTx {
    return new MsgEthereumTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgEthereumTx {
    return new MsgEthereumTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgEthereumTx {
    return new MsgEthereumTx().fromJsonString(jsonString, options);
  }

  static equals(a: MsgEthereumTx | PlainMessage<MsgEthereumTx> | undefined, b: MsgEthereumTx | PlainMessage<MsgEthereumTx> | undefined): boolean {
    return proto3.util.equals(MsgEthereumTx, a, b);
  }
}

/**
 * LegacyTx is the transaction data of regular Ethereum transactions.
 * NOTE: All non-protected transactions (i.e non EIP155 signed) will fail if the
 * AllowUnprotectedTxs parameter is disabled.
 *
 * @generated from message ethermint.evm.v1.LegacyTx
 */
export class LegacyTx extends Message<LegacyTx> {
  /**
   * nonce corresponds to the account nonce (transaction sequence).
   *
   * @generated from field: uint64 nonce = 1;
   */
  nonce = protoInt64.zero;

  /**
   * gas_price defines the value for each gas unit
   *
   * @generated from field: string gas_price = 2;
   */
  gasPrice = "";

  /**
   * gas defines the gas limit defined for the transaction.
   *
   * @generated from field: uint64 gas = 3;
   */
  gas = protoInt64.zero;

  /**
   * to is the hex formatted address of the recipient
   *
   * @generated from field: string to = 4;
   */
  to = "";

  /**
   * value defines the unsigned integer value of the transaction amount.
   *
   * @generated from field: string value = 5;
   */
  value = "";

  /**
   * data is the data payload bytes of the transaction.
   *
   * @generated from field: bytes data = 6;
   */
  data = new Uint8Array(0);

  /**
   * v defines the signature value
   *
   * @generated from field: bytes v = 7;
   */
  v = new Uint8Array(0);

  /**
   * r defines the signature value
   *
   * @generated from field: bytes r = 8;
   */
  r = new Uint8Array(0);

  /**
   * s define the signature value
   *
   * @generated from field: bytes s = 9;
   */
  s = new Uint8Array(0);

  constructor(data?: PartialMessage<LegacyTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.LegacyTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "gas_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LegacyTx {
    return new LegacyTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LegacyTx {
    return new LegacyTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LegacyTx {
    return new LegacyTx().fromJsonString(jsonString, options);
  }

  static equals(a: LegacyTx | PlainMessage<LegacyTx> | undefined, b: LegacyTx | PlainMessage<LegacyTx> | undefined): boolean {
    return proto3.util.equals(LegacyTx, a, b);
  }
}

/**
 * AccessListTx is the data of EIP-2930 access list transactions.
 *
 * @generated from message ethermint.evm.v1.AccessListTx
 */
export class AccessListTx extends Message<AccessListTx> {
  /**
   * chain_id of the destination EVM chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * nonce corresponds to the account nonce (transaction sequence).
   *
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  /**
   * gas_price defines the value for each gas unit
   *
   * @generated from field: string gas_price = 3;
   */
  gasPrice = "";

  /**
   * gas defines the gas limit defined for the transaction.
   *
   * @generated from field: uint64 gas = 4;
   */
  gas = protoInt64.zero;

  /**
   * to is the recipient address in hex format
   *
   * @generated from field: string to = 5;
   */
  to = "";

  /**
   * value defines the unsigned integer value of the transaction amount.
   *
   * @generated from field: string value = 6;
   */
  value = "";

  /**
   * data is the data payload bytes of the transaction.
   *
   * @generated from field: bytes data = 7;
   */
  data = new Uint8Array(0);

  /**
   * accesses is an array of access tuples
   *
   * @generated from field: repeated ethermint.evm.v1.AccessTuple accesses = 8;
   */
  accesses: AccessTuple[] = [];

  /**
   * v defines the signature value
   *
   * @generated from field: bytes v = 9;
   */
  v = new Uint8Array(0);

  /**
   * r defines the signature value
   *
   * @generated from field: bytes r = 10;
   */
  r = new Uint8Array(0);

  /**
   * s define the signature value
   *
   * @generated from field: bytes s = 11;
   */
  s = new Uint8Array(0);

  constructor(data?: PartialMessage<AccessListTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.AccessListTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "gas_price", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 8, name: "accesses", kind: "message", T: AccessTuple, repeated: true },
    { no: 9, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 10, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AccessListTx {
    return new AccessListTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AccessListTx {
    return new AccessListTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AccessListTx {
    return new AccessListTx().fromJsonString(jsonString, options);
  }

  static equals(a: AccessListTx | PlainMessage<AccessListTx> | undefined, b: AccessListTx | PlainMessage<AccessListTx> | undefined): boolean {
    return proto3.util.equals(AccessListTx, a, b);
  }
}

/**
 * DynamicFeeTx is the data of EIP-1559 dinamic fee transactions.
 *
 * @generated from message ethermint.evm.v1.DynamicFeeTx
 */
export class DynamicFeeTx extends Message<DynamicFeeTx> {
  /**
   * chain_id of the destination EVM chain
   *
   * @generated from field: string chain_id = 1;
   */
  chainId = "";

  /**
   * nonce corresponds to the account nonce (transaction sequence).
   *
   * @generated from field: uint64 nonce = 2;
   */
  nonce = protoInt64.zero;

  /**
   * gas_tip_cap defines the max value for the gas tip
   *
   * @generated from field: string gas_tip_cap = 3;
   */
  gasTipCap = "";

  /**
   * gas_fee_cap defines the max value for the gas fee
   *
   * @generated from field: string gas_fee_cap = 4;
   */
  gasFeeCap = "";

  /**
   * gas defines the gas limit defined for the transaction.
   *
   * @generated from field: uint64 gas = 5;
   */
  gas = protoInt64.zero;

  /**
   * to is the hex formatted address of the recipient
   *
   * @generated from field: string to = 6;
   */
  to = "";

  /**
   * value defines the the transaction amount.
   *
   * @generated from field: string value = 7;
   */
  value = "";

  /**
   * data is the data payload bytes of the transaction.
   *
   * @generated from field: bytes data = 8;
   */
  data = new Uint8Array(0);

  /**
   * accesses is an array of access tuples
   *
   * @generated from field: repeated ethermint.evm.v1.AccessTuple accesses = 9;
   */
  accesses: AccessTuple[] = [];

  /**
   * v defines the signature value
   *
   * @generated from field: bytes v = 10;
   */
  v = new Uint8Array(0);

  /**
   * r defines the signature value
   *
   * @generated from field: bytes r = 11;
   */
  r = new Uint8Array(0);

  /**
   * s define the signature value
   *
   * @generated from field: bytes s = 12;
   */
  s = new Uint8Array(0);

  constructor(data?: PartialMessage<DynamicFeeTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.DynamicFeeTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nonce", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "gas_tip_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "gas_fee_cap", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gas", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 6, name: "to", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 9, name: "accesses", kind: "message", T: AccessTuple, repeated: true },
    { no: 10, name: "v", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 11, name: "r", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 12, name: "s", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DynamicFeeTx {
    return new DynamicFeeTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DynamicFeeTx {
    return new DynamicFeeTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DynamicFeeTx {
    return new DynamicFeeTx().fromJsonString(jsonString, options);
  }

  static equals(a: DynamicFeeTx | PlainMessage<DynamicFeeTx> | undefined, b: DynamicFeeTx | PlainMessage<DynamicFeeTx> | undefined): boolean {
    return proto3.util.equals(DynamicFeeTx, a, b);
  }
}

/**
 * ExtensionOptionsEthereumTx is an extension option for ethereum transactions
 *
 * @generated from message ethermint.evm.v1.ExtensionOptionsEthereumTx
 */
export class ExtensionOptionsEthereumTx extends Message<ExtensionOptionsEthereumTx> {
  constructor(data?: PartialMessage<ExtensionOptionsEthereumTx>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.ExtensionOptionsEthereumTx";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ExtensionOptionsEthereumTx {
    return new ExtensionOptionsEthereumTx().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ExtensionOptionsEthereumTx {
    return new ExtensionOptionsEthereumTx().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ExtensionOptionsEthereumTx {
    return new ExtensionOptionsEthereumTx().fromJsonString(jsonString, options);
  }

  static equals(a: ExtensionOptionsEthereumTx | PlainMessage<ExtensionOptionsEthereumTx> | undefined, b: ExtensionOptionsEthereumTx | PlainMessage<ExtensionOptionsEthereumTx> | undefined): boolean {
    return proto3.util.equals(ExtensionOptionsEthereumTx, a, b);
  }
}

/**
 * MsgEthereumTxResponse defines the Msg/EthereumTx response type.
 *
 * @generated from message ethermint.evm.v1.MsgEthereumTxResponse
 */
export class MsgEthereumTxResponse extends Message<MsgEthereumTxResponse> {
  /**
   * hash of the ethereum transaction in hex format. This hash differs from the
   * Tendermint sha256 hash of the transaction bytes. See
   * https://github.com/tendermint/tendermint/issues/6539 for reference
   *
   * @generated from field: string hash = 1;
   */
  hash = "";

  /**
   * logs contains the transaction hash and the proto-compatible ethereum
   * logs.
   *
   * @generated from field: repeated ethermint.evm.v1.Log logs = 2;
   */
  logs: Log[] = [];

  /**
   * ret is the returned data from evm function (result or data supplied with
   * revert opcode)
   *
   * @generated from field: bytes ret = 3;
   */
  ret = new Uint8Array(0);

  /**
   * vm_error is the error returned by vm execution
   *
   * @generated from field: string vm_error = 4;
   */
  vmError = "";

  /**
   * gas_used specifies how much gas was consumed by the transaction
   *
   * @generated from field: uint64 gas_used = 5;
   */
  gasUsed = protoInt64.zero;

  constructor(data?: PartialMessage<MsgEthereumTxResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.MsgEthereumTxResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "hash", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "logs", kind: "message", T: Log, repeated: true },
    { no: 3, name: "ret", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 4, name: "vm_error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "gas_used", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgEthereumTxResponse {
    return new MsgEthereumTxResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgEthereumTxResponse {
    return new MsgEthereumTxResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgEthereumTxResponse {
    return new MsgEthereumTxResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgEthereumTxResponse | PlainMessage<MsgEthereumTxResponse> | undefined, b: MsgEthereumTxResponse | PlainMessage<MsgEthereumTxResponse> | undefined): boolean {
    return proto3.util.equals(MsgEthereumTxResponse, a, b);
  }
}

/**
 * MsgUpdateParams defines a Msg for updating the x/evm module parameters.
 *
 * @generated from message ethermint.evm.v1.MsgUpdateParams
 */
export class MsgUpdateParams extends Message<MsgUpdateParams> {
  /**
   * authority is the address of the governance account.
   *
   * @generated from field: string authority = 1;
   */
  authority = "";

  /**
   * params defines the x/evm parameters to update.
   * NOTE: All parameters must be supplied.
   *
   * @generated from field: ethermint.evm.v1.Params params = 2;
   */
  params?: Params;

  constructor(data?: PartialMessage<MsgUpdateParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.MsgUpdateParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authority", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "params", kind: "message", T: Params },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParams {
    return new MsgUpdateParams().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined, b: MsgUpdateParams | PlainMessage<MsgUpdateParams> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParams, a, b);
  }
}

/**
 * MsgUpdateParamsResponse defines the response structure for executing a
 * MsgUpdateParams message.
 *
 * @generated from message ethermint.evm.v1.MsgUpdateParamsResponse
 */
export class MsgUpdateParamsResponse extends Message<MsgUpdateParamsResponse> {
  constructor(data?: PartialMessage<MsgUpdateParamsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "ethermint.evm.v1.MsgUpdateParamsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgUpdateParamsResponse {
    return new MsgUpdateParamsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined, b: MsgUpdateParamsResponse | PlainMessage<MsgUpdateParamsResponse> | undefined): boolean {
    return proto3.util.equals(MsgUpdateParamsResponse, a, b);
  }
}

