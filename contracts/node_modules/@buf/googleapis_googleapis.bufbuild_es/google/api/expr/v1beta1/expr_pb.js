// Copyright 2019 Google LLC.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// @generated by protoc-gen-es v1.0.0
// @generated from file google/api/expr/v1beta1/expr.proto (package google.api.expr.v1beta1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { NullValue, proto3 } from "@bufbuild/protobuf";
import { SourceInfo } from "./source_pb.js";

/**
 * An expression together with source information as returned by the parser.
 *
 * @generated from message google.api.expr.v1beta1.ParsedExpr
 */
export const ParsedExpr = proto3.makeMessageType(
  "google.api.expr.v1beta1.ParsedExpr",
  () => [
    { no: 2, name: "expr", kind: "message", T: Expr },
    { no: 3, name: "source_info", kind: "message", T: SourceInfo },
    { no: 4, name: "syntax_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * An abstract representation of a common expression.
 *
 * Expressions are abstractly represented as a collection of identifiers,
 * select statements, function calls, literals, and comprehensions. All
 * operators with the exception of the '.' operator are modelled as function
 * calls. This makes it easy to represent new operators into the existing AST.
 *
 * All references within expressions must resolve to a [Decl][google.api.expr.v1beta1.Decl] provided at
 * type-check for an expression to be valid. A reference may either be a bare
 * identifier `name` or a qualified identifier `google.api.name`. References
 * may either refer to a value or a function declaration.
 *
 * For example, the expression `google.api.name.startsWith('expr')` references
 * the declaration `google.api.name` within a [Expr.Select][google.api.expr.v1beta1.Expr.Select] expression, and
 * the function declaration `startsWith`.
 *
 * @generated from message google.api.expr.v1beta1.Expr
 */
export const Expr = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr",
  () => [
    { no: 2, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "literal_expr", kind: "message", T: Literal, oneof: "expr_kind" },
    { no: 4, name: "ident_expr", kind: "message", T: Expr_Ident, oneof: "expr_kind" },
    { no: 5, name: "select_expr", kind: "message", T: Expr_Select, oneof: "expr_kind" },
    { no: 6, name: "call_expr", kind: "message", T: Expr_Call, oneof: "expr_kind" },
    { no: 7, name: "list_expr", kind: "message", T: Expr_CreateList, oneof: "expr_kind" },
    { no: 8, name: "struct_expr", kind: "message", T: Expr_CreateStruct, oneof: "expr_kind" },
    { no: 9, name: "comprehension_expr", kind: "message", T: Expr_Comprehension, oneof: "expr_kind" },
  ],
);

/**
 * An identifier expression. e.g. `request`.
 *
 * @generated from message google.api.expr.v1beta1.Expr.Ident
 */
export const Expr_Ident = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.Ident",
  () => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
  {localName: "Expr_Ident"},
);

/**
 * A field selection expression. e.g. `request.auth`.
 *
 * @generated from message google.api.expr.v1beta1.Expr.Select
 */
export const Expr_Select = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.Select",
  () => [
    { no: 1, name: "operand", kind: "message", T: Expr },
    { no: 2, name: "field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "test_only", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ],
  {localName: "Expr_Select"},
);

/**
 * A call expression, including calls to predefined functions and operators.
 *
 * For example, `value == 10`, `size(map_value)`.
 *
 * @generated from message google.api.expr.v1beta1.Expr.Call
 */
export const Expr_Call = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.Call",
  () => [
    { no: 1, name: "target", kind: "message", T: Expr },
    { no: 2, name: "function", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "args", kind: "message", T: Expr, repeated: true },
  ],
  {localName: "Expr_Call"},
);

/**
 * A list creation expression.
 *
 * Lists may either be homogenous, e.g. `[1, 2, 3]`, or heterogenous, e.g.
 * `dyn([1, 'hello', 2.0])`
 *
 * @generated from message google.api.expr.v1beta1.Expr.CreateList
 */
export const Expr_CreateList = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.CreateList",
  () => [
    { no: 1, name: "elements", kind: "message", T: Expr, repeated: true },
  ],
  {localName: "Expr_CreateList"},
);

/**
 * A map or message creation expression.
 *
 * Maps are constructed as `{'key_name': 'value'}`. Message construction is
 * similar, but prefixed with a type name and composed of field ids:
 * `types.MyType{field_id: 'value'}`.
 *
 * @generated from message google.api.expr.v1beta1.Expr.CreateStruct
 */
export const Expr_CreateStruct = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.CreateStruct",
  () => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "entries", kind: "message", T: Expr_CreateStruct_Entry, repeated: true },
  ],
  {localName: "Expr_CreateStruct"},
);

/**
 * Represents an entry.
 *
 * @generated from message google.api.expr.v1beta1.Expr.CreateStruct.Entry
 */
export const Expr_CreateStruct_Entry = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.CreateStruct.Entry",
  () => [
    { no: 1, name: "id", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 2, name: "field_key", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "key_kind" },
    { no: 3, name: "map_key", kind: "message", T: Expr, oneof: "key_kind" },
    { no: 4, name: "value", kind: "message", T: Expr },
  ],
  {localName: "Expr_CreateStruct_Entry"},
);

/**
 * A comprehension expression applied to a list or map.
 *
 * Comprehensions are not part of the core syntax, but enabled with macros.
 * A macro matches a specific call signature within a parsed AST and replaces
 * the call with an alternate AST block. Macro expansion happens at parse
 * time.
 *
 * The following macros are supported within CEL:
 *
 * Aggregate type macros may be applied to all elements in a list or all keys
 * in a map:
 *
 * *  `all`, `exists`, `exists_one` -  test a predicate expression against
 *    the inputs and return `true` if the predicate is satisfied for all,
 *    any, or only one value `list.all(x, x < 10)`.
 * *  `filter` - test a predicate expression against the inputs and return
 *    the subset of elements which satisfy the predicate:
 *    `payments.filter(p, p > 1000)`.
 * *  `map` - apply an expression to all elements in the input and return the
 *    output aggregate type: `[1, 2, 3].map(i, i * i)`.
 *
 * The `has(m.x)` macro tests whether the property `x` is present in struct
 * `m`. The semantics of this macro depend on the type of `m`. For proto2
 * messages `has(m.x)` is defined as 'defined, but not set`. For proto3, the
 * macro tests whether the property is set to its default. For map and struct
 * types, the macro tests whether the property `x` is defined on `m`.
 *
 * @generated from message google.api.expr.v1beta1.Expr.Comprehension
 */
export const Expr_Comprehension = proto3.makeMessageType(
  "google.api.expr.v1beta1.Expr.Comprehension",
  () => [
    { no: 1, name: "iter_var", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "iter_range", kind: "message", T: Expr },
    { no: 3, name: "accu_var", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "accu_init", kind: "message", T: Expr },
    { no: 5, name: "loop_condition", kind: "message", T: Expr },
    { no: 6, name: "loop_step", kind: "message", T: Expr },
    { no: 7, name: "result", kind: "message", T: Expr },
  ],
  {localName: "Expr_Comprehension"},
);

/**
 * Represents a primitive literal.
 *
 * This is similar to the primitives supported in the well-known type
 * `google.protobuf.Value`, but richer so it can represent CEL's full range of
 * primitives.
 *
 * Lists and structs are not included as constants as these aggregate types may
 * contain [Expr][google.api.expr.v1beta1.Expr] elements which require evaluation and are thus not constant.
 *
 * Examples of literals include: `"hello"`, `b'bytes'`, `1u`, `4.2`, `-2`,
 * `true`, `null`.
 *
 * @generated from message google.api.expr.v1beta1.Literal
 */
export const Literal = proto3.makeMessageType(
  "google.api.expr.v1beta1.Literal",
  () => [
    { no: 1, name: "null_value", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "constant_kind" },
    { no: 2, name: "bool_value", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "constant_kind" },
    { no: 3, name: "int64_value", kind: "scalar", T: 3 /* ScalarType.INT64 */, oneof: "constant_kind" },
    { no: 4, name: "uint64_value", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "constant_kind" },
    { no: 5, name: "double_value", kind: "scalar", T: 1 /* ScalarType.DOUBLE */, oneof: "constant_kind" },
    { no: 6, name: "string_value", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "constant_kind" },
    { no: 7, name: "bytes_value", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "constant_kind" },
  ],
);

