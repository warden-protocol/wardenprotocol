// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: warden/warden/v1beta3/tx.proto

package wardenv1beta3

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Msg_UpdateParams_FullMethodName        = "/warden.warden.v1beta3.Msg/UpdateParams"
	Msg_NewSpace_FullMethodName            = "/warden.warden.v1beta3.Msg/NewSpace"
	Msg_AddSpaceOwner_FullMethodName       = "/warden.warden.v1beta3.Msg/AddSpaceOwner"
	Msg_RemoveSpaceOwner_FullMethodName    = "/warden.warden.v1beta3.Msg/RemoveSpaceOwner"
	Msg_NewKeychain_FullMethodName         = "/warden.warden.v1beta3.Msg/NewKeychain"
	Msg_AddKeychainWriter_FullMethodName   = "/warden.warden.v1beta3.Msg/AddKeychainWriter"
	Msg_UpdateSpace_FullMethodName         = "/warden.warden.v1beta3.Msg/UpdateSpace"
	Msg_UpdateKeychain_FullMethodName      = "/warden.warden.v1beta3.Msg/UpdateKeychain"
	Msg_NewKeyRequest_FullMethodName       = "/warden.warden.v1beta3.Msg/NewKeyRequest"
	Msg_FulfilKeyRequest_FullMethodName    = "/warden.warden.v1beta3.Msg/FulfilKeyRequest"
	Msg_UpdateKey_FullMethodName           = "/warden.warden.v1beta3.Msg/UpdateKey"
	Msg_NewSignRequest_FullMethodName      = "/warden.warden.v1beta3.Msg/NewSignRequest"
	Msg_FulfilSignRequest_FullMethodName   = "/warden.warden.v1beta3.Msg/FulfilSignRequest"
	Msg_AddKeychainAdmin_FullMethodName    = "/warden.warden.v1beta3.Msg/AddKeychainAdmin"
	Msg_RemoveKeychainAdmin_FullMethodName = "/warden.warden.v1beta3.Msg/RemoveKeychainAdmin"
)

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Msg defines the Msg service.
type MsgClient interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
	// Create a new Space. The creator will be the first owner of the Space.
	NewSpace(ctx context.Context, in *MsgNewSpace, opts ...grpc.CallOption) (*MsgNewSpaceResponse, error)
	// Add a new owner to a Space.
	AddSpaceOwner(ctx context.Context, in *MsgAddSpaceOwner, opts ...grpc.CallOption) (*MsgAddSpaceOwnerResponse, error)
	// Remove an owner from the Space.
	RemoveSpaceOwner(ctx context.Context, in *MsgRemoveSpaceOwner, opts ...grpc.CallOption) (*MsgRemoveSpaceOwnerResponse, error)
	// Create a new Keychain. The user will be the first admin of the Keychain.
	NewKeychain(ctx context.Context, in *MsgNewKeychain, opts ...grpc.CallOption) (*MsgNewKeychainResponse, error)
	// Add a new writer to a Keychain.
	AddKeychainWriter(ctx context.Context, in *MsgAddKeychainWriter, opts ...grpc.CallOption) (*MsgAddKeychainWriterResponse, error)
	// Update a Space.
	UpdateSpace(ctx context.Context, in *MsgUpdateSpace, opts ...grpc.CallOption) (*MsgUpdateSpaceResponse, error)
	// Update a Keychain.
	UpdateKeychain(ctx context.Context, in *MsgUpdateKeychain, opts ...grpc.CallOption) (*MsgUpdateKeychainResponse, error)
	// Create a new KeyRequest.
	NewKeyRequest(ctx context.Context, in *MsgNewKeyRequest, opts ...grpc.CallOption) (*MsgNewKeyRequestResponse, error)
	// Fulfil or reject a KeyRequest.
	FulfilKeyRequest(ctx context.Context, in *MsgFulfilKeyRequest, opts ...grpc.CallOption) (*MsgFulfilKeyRequestResponse, error)
	// Update a Key.
	UpdateKey(ctx context.Context, in *MsgUpdateKey, opts ...grpc.CallOption) (*MsgUpdateKeyResponse, error)
	// Create a new SignRequest.
	NewSignRequest(ctx context.Context, in *MsgNewSignRequest, opts ...grpc.CallOption) (*MsgNewSignRequestResponse, error)
	// Fulfil or reject a SignRequest.
	FulfilSignRequest(ctx context.Context, in *MsgFulfilSignRequest, opts ...grpc.CallOption) (*MsgFulfilSignRequestResponse, error)
	// Add a new admin to a Keychain
	AddKeychainAdmin(ctx context.Context, in *MsgAddKeychainAdminRequest, opts ...grpc.CallOption) (*MsgAddKeychainAdminResponse, error)
	// / Remove admin from a Keychain
	RemoveKeychainAdmin(ctx context.Context, in *MsgRemoveKeychainAdminRequest, opts ...grpc.CallOption) (*MsgRemoveKeychainAdminResponse, error)
}

type msgClient struct {
	cc grpc.ClientConnInterface
}

func NewMsgClient(cc grpc.ClientConnInterface) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateParams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewSpace(ctx context.Context, in *MsgNewSpace, opts ...grpc.CallOption) (*MsgNewSpaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgNewSpaceResponse)
	err := c.cc.Invoke(ctx, Msg_NewSpace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddSpaceOwner(ctx context.Context, in *MsgAddSpaceOwner, opts ...grpc.CallOption) (*MsgAddSpaceOwnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAddSpaceOwnerResponse)
	err := c.cc.Invoke(ctx, Msg_AddSpaceOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveSpaceOwner(ctx context.Context, in *MsgRemoveSpaceOwner, opts ...grpc.CallOption) (*MsgRemoveSpaceOwnerResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRemoveSpaceOwnerResponse)
	err := c.cc.Invoke(ctx, Msg_RemoveSpaceOwner_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewKeychain(ctx context.Context, in *MsgNewKeychain, opts ...grpc.CallOption) (*MsgNewKeychainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgNewKeychainResponse)
	err := c.cc.Invoke(ctx, Msg_NewKeychain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddKeychainWriter(ctx context.Context, in *MsgAddKeychainWriter, opts ...grpc.CallOption) (*MsgAddKeychainWriterResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAddKeychainWriterResponse)
	err := c.cc.Invoke(ctx, Msg_AddKeychainWriter_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateSpace(ctx context.Context, in *MsgUpdateSpace, opts ...grpc.CallOption) (*MsgUpdateSpaceResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateSpaceResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateSpace_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateKeychain(ctx context.Context, in *MsgUpdateKeychain, opts ...grpc.CallOption) (*MsgUpdateKeychainResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateKeychainResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateKeychain_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewKeyRequest(ctx context.Context, in *MsgNewKeyRequest, opts ...grpc.CallOption) (*MsgNewKeyRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgNewKeyRequestResponse)
	err := c.cc.Invoke(ctx, Msg_NewKeyRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) FulfilKeyRequest(ctx context.Context, in *MsgFulfilKeyRequest, opts ...grpc.CallOption) (*MsgFulfilKeyRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgFulfilKeyRequestResponse)
	err := c.cc.Invoke(ctx, Msg_FulfilKeyRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateKey(ctx context.Context, in *MsgUpdateKey, opts ...grpc.CallOption) (*MsgUpdateKeyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgUpdateKeyResponse)
	err := c.cc.Invoke(ctx, Msg_UpdateKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) NewSignRequest(ctx context.Context, in *MsgNewSignRequest, opts ...grpc.CallOption) (*MsgNewSignRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgNewSignRequestResponse)
	err := c.cc.Invoke(ctx, Msg_NewSignRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) FulfilSignRequest(ctx context.Context, in *MsgFulfilSignRequest, opts ...grpc.CallOption) (*MsgFulfilSignRequestResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgFulfilSignRequestResponse)
	err := c.cc.Invoke(ctx, Msg_FulfilSignRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AddKeychainAdmin(ctx context.Context, in *MsgAddKeychainAdminRequest, opts ...grpc.CallOption) (*MsgAddKeychainAdminResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgAddKeychainAdminResponse)
	err := c.cc.Invoke(ctx, Msg_AddKeychainAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RemoveKeychainAdmin(ctx context.Context, in *MsgRemoveKeychainAdminRequest, opts ...grpc.CallOption) (*MsgRemoveKeychainAdminResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MsgRemoveKeychainAdminResponse)
	err := c.cc.Invoke(ctx, Msg_RemoveKeychainAdmin_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
// All implementations must embed UnimplementedMsgServer
// for forward compatibility.
//
// Msg defines the Msg service.
type MsgServer interface {
	// UpdateParams defines a (governance) operation for updating the module
	// parameters. The authority defaults to the x/gov module account.
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
	// Create a new Space. The creator will be the first owner of the Space.
	NewSpace(context.Context, *MsgNewSpace) (*MsgNewSpaceResponse, error)
	// Add a new owner to a Space.
	AddSpaceOwner(context.Context, *MsgAddSpaceOwner) (*MsgAddSpaceOwnerResponse, error)
	// Remove an owner from the Space.
	RemoveSpaceOwner(context.Context, *MsgRemoveSpaceOwner) (*MsgRemoveSpaceOwnerResponse, error)
	// Create a new Keychain. The user will be the first admin of the Keychain.
	NewKeychain(context.Context, *MsgNewKeychain) (*MsgNewKeychainResponse, error)
	// Add a new writer to a Keychain.
	AddKeychainWriter(context.Context, *MsgAddKeychainWriter) (*MsgAddKeychainWriterResponse, error)
	// Update a Space.
	UpdateSpace(context.Context, *MsgUpdateSpace) (*MsgUpdateSpaceResponse, error)
	// Update a Keychain.
	UpdateKeychain(context.Context, *MsgUpdateKeychain) (*MsgUpdateKeychainResponse, error)
	// Create a new KeyRequest.
	NewKeyRequest(context.Context, *MsgNewKeyRequest) (*MsgNewKeyRequestResponse, error)
	// Fulfil or reject a KeyRequest.
	FulfilKeyRequest(context.Context, *MsgFulfilKeyRequest) (*MsgFulfilKeyRequestResponse, error)
	// Update a Key.
	UpdateKey(context.Context, *MsgUpdateKey) (*MsgUpdateKeyResponse, error)
	// Create a new SignRequest.
	NewSignRequest(context.Context, *MsgNewSignRequest) (*MsgNewSignRequestResponse, error)
	// Fulfil or reject a SignRequest.
	FulfilSignRequest(context.Context, *MsgFulfilSignRequest) (*MsgFulfilSignRequestResponse, error)
	// Add a new admin to a Keychain
	AddKeychainAdmin(context.Context, *MsgAddKeychainAdminRequest) (*MsgAddKeychainAdminResponse, error)
	// / Remove admin from a Keychain
	RemoveKeychainAdmin(context.Context, *MsgRemoveKeychainAdminRequest) (*MsgRemoveKeychainAdminResponse, error)
	mustEmbedUnimplementedMsgServer()
}

// UnimplementedMsgServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMsgServer struct{}

func (UnimplementedMsgServer) UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}
func (UnimplementedMsgServer) NewSpace(context.Context, *MsgNewSpace) (*MsgNewSpaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewSpace not implemented")
}
func (UnimplementedMsgServer) AddSpaceOwner(context.Context, *MsgAddSpaceOwner) (*MsgAddSpaceOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSpaceOwner not implemented")
}
func (UnimplementedMsgServer) RemoveSpaceOwner(context.Context, *MsgRemoveSpaceOwner) (*MsgRemoveSpaceOwnerResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveSpaceOwner not implemented")
}
func (UnimplementedMsgServer) NewKeychain(context.Context, *MsgNewKeychain) (*MsgNewKeychainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewKeychain not implemented")
}
func (UnimplementedMsgServer) AddKeychainWriter(context.Context, *MsgAddKeychainWriter) (*MsgAddKeychainWriterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddKeychainWriter not implemented")
}
func (UnimplementedMsgServer) UpdateSpace(context.Context, *MsgUpdateSpace) (*MsgUpdateSpaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSpace not implemented")
}
func (UnimplementedMsgServer) UpdateKeychain(context.Context, *MsgUpdateKeychain) (*MsgUpdateKeychainResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKeychain not implemented")
}
func (UnimplementedMsgServer) NewKeyRequest(context.Context, *MsgNewKeyRequest) (*MsgNewKeyRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewKeyRequest not implemented")
}
func (UnimplementedMsgServer) FulfilKeyRequest(context.Context, *MsgFulfilKeyRequest) (*MsgFulfilKeyRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FulfilKeyRequest not implemented")
}
func (UnimplementedMsgServer) UpdateKey(context.Context, *MsgUpdateKey) (*MsgUpdateKeyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateKey not implemented")
}
func (UnimplementedMsgServer) NewSignRequest(context.Context, *MsgNewSignRequest) (*MsgNewSignRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NewSignRequest not implemented")
}
func (UnimplementedMsgServer) FulfilSignRequest(context.Context, *MsgFulfilSignRequest) (*MsgFulfilSignRequestResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FulfilSignRequest not implemented")
}
func (UnimplementedMsgServer) AddKeychainAdmin(context.Context, *MsgAddKeychainAdminRequest) (*MsgAddKeychainAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddKeychainAdmin not implemented")
}
func (UnimplementedMsgServer) RemoveKeychainAdmin(context.Context, *MsgRemoveKeychainAdminRequest) (*MsgRemoveKeychainAdminResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveKeychainAdmin not implemented")
}
func (UnimplementedMsgServer) mustEmbedUnimplementedMsgServer() {}
func (UnimplementedMsgServer) testEmbeddedByValue()             {}

// UnsafeMsgServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MsgServer will
// result in compilation errors.
type UnsafeMsgServer interface {
	mustEmbedUnimplementedMsgServer()
}

func RegisterMsgServer(s grpc.ServiceRegistrar, srv MsgServer) {
	// If the following call pancis, it indicates UnimplementedMsgServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Msg_ServiceDesc, srv)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateParams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewSpace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewSpace)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewSpace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NewSpace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewSpace(ctx, req.(*MsgNewSpace))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddSpaceOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddSpaceOwner)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddSpaceOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AddSpaceOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddSpaceOwner(ctx, req.(*MsgAddSpaceOwner))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveSpaceOwner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveSpaceOwner)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveSpaceOwner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RemoveSpaceOwner_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveSpaceOwner(ctx, req.(*MsgRemoveSpaceOwner))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewKeychain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewKeychain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewKeychain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NewKeychain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewKeychain(ctx, req.(*MsgNewKeychain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddKeychainWriter_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddKeychainWriter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddKeychainWriter(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AddKeychainWriter_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddKeychainWriter(ctx, req.(*MsgAddKeychainWriter))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateSpace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateSpace)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateSpace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateSpace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateSpace(ctx, req.(*MsgUpdateSpace))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateKeychain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateKeychain)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateKeychain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateKeychain_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateKeychain(ctx, req.(*MsgUpdateKeychain))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewKeyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewKeyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NewKeyRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewKeyRequest(ctx, req.(*MsgNewKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_FulfilKeyRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFulfilKeyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).FulfilKeyRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_FulfilKeyRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).FulfilKeyRequest(ctx, req.(*MsgFulfilKeyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_UpdateKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateKey(ctx, req.(*MsgUpdateKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_NewSignRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgNewSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).NewSignRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_NewSignRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).NewSignRequest(ctx, req.(*MsgNewSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_FulfilSignRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFulfilSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).FulfilSignRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_FulfilSignRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).FulfilSignRequest(ctx, req.(*MsgFulfilSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AddKeychainAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAddKeychainAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AddKeychainAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_AddKeychainAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AddKeychainAdmin(ctx, req.(*MsgAddKeychainAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RemoveKeychainAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRemoveKeychainAdminRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RemoveKeychainAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Msg_RemoveKeychainAdmin_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RemoveKeychainAdmin(ctx, req.(*MsgRemoveKeychainAdminRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Msg_ServiceDesc is the grpc.ServiceDesc for Msg service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Msg_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "warden.warden.v1beta3.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
		{
			MethodName: "NewSpace",
			Handler:    _Msg_NewSpace_Handler,
		},
		{
			MethodName: "AddSpaceOwner",
			Handler:    _Msg_AddSpaceOwner_Handler,
		},
		{
			MethodName: "RemoveSpaceOwner",
			Handler:    _Msg_RemoveSpaceOwner_Handler,
		},
		{
			MethodName: "NewKeychain",
			Handler:    _Msg_NewKeychain_Handler,
		},
		{
			MethodName: "AddKeychainWriter",
			Handler:    _Msg_AddKeychainWriter_Handler,
		},
		{
			MethodName: "UpdateSpace",
			Handler:    _Msg_UpdateSpace_Handler,
		},
		{
			MethodName: "UpdateKeychain",
			Handler:    _Msg_UpdateKeychain_Handler,
		},
		{
			MethodName: "NewKeyRequest",
			Handler:    _Msg_NewKeyRequest_Handler,
		},
		{
			MethodName: "FulfilKeyRequest",
			Handler:    _Msg_FulfilKeyRequest_Handler,
		},
		{
			MethodName: "UpdateKey",
			Handler:    _Msg_UpdateKey_Handler,
		},
		{
			MethodName: "NewSignRequest",
			Handler:    _Msg_NewSignRequest_Handler,
		},
		{
			MethodName: "FulfilSignRequest",
			Handler:    _Msg_FulfilSignRequest_Handler,
		},
		{
			MethodName: "AddKeychainAdmin",
			Handler:    _Msg_AddKeychainAdmin_Handler,
		},
		{
			MethodName: "RemoveKeychainAdmin",
			Handler:    _Msg_RemoveKeychainAdmin_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "warden/warden/v1beta3/tx.proto",
}
