"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable @typescript-eslint/naming-convention */
const encoding_1 = require("@cosmjs/encoding");
const stream_1 = require("@cosmjs/stream");
const utils_1 = require("@cosmjs/utils");
const readonly_date_1 = require("readonly-date");
const xstream_1 = require("xstream");
const rpcclients_1 = require("../rpcclients");
const testutil_spec_1 = require("../testutil.spec");
const adaptor_1 = require("./adaptor");
const requests_1 = require("./requests");
const responses = __importStar(require("./responses"));
const tendermint34client_1 = require("./tendermint34client");
function defaultTestSuite(rpcFactory, expected) {
    describe("create", () => {
        it("can auto-discover Tendermint version and communicate", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const info = await client.abciInfo();
            expect(info).toBeTruthy();
            client.disconnect();
        });
        it("can connect to Tendermint with known version", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            expect(await client.abciInfo()).toBeTruthy();
            client.disconnect();
        });
    });
    it("can get genesis", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const genesis = await client.genesis();
        expect(genesis).toBeTruthy();
        client.disconnect();
    });
    describe("broadcastTxCommit", () => {
        it("can broadcast a transaction", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const tx = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
            const response = await client.broadcastTxCommit({ tx: tx });
            expect(response.height).toBeGreaterThan(2);
            expect(response.hash).toBeTruthy();
            // verify success
            expect(response.checkTx.code).toBeFalsy();
            expect(response.deliverTx).toBeTruthy();
            if (response.deliverTx) {
                expect(response.deliverTx.code).toBeFalsy();
            }
            client.disconnect();
        });
    });
    describe("broadcastTxSync", () => {
        it("can broadcast a transaction", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const tx = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
            const response = await client.broadcastTxSync({ tx: tx });
            expect(response.hash.length).toEqual(32);
            // verify success
            expect(response.code).toBeFalsy();
            expect(response.codeSpace).toBeFalsy();
            client.disconnect();
        });
    });
    describe("broadcastTxAsync", () => {
        it("can broadcast a transaction", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const tx = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
            const response = await client.broadcastTxAsync({ tx: tx });
            expect(response.hash.length).toEqual(32);
            client.disconnect();
        });
    });
    it("gets the same tx hash from backend as calculated locally", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const tx = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        const calculatedTxHash = adaptor_1.adaptor34.hashTx(tx);
        const response = await client.broadcastTxCommit({ tx: tx });
        expect(response.hash).toEqual(calculatedTxHash);
        client.disconnect();
    });
    it("can query the state", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const key = (0, testutil_spec_1.randomString)();
        const value = (0, testutil_spec_1.randomString)();
        await client.broadcastTxCommit({ tx: (0, testutil_spec_1.buildKvTx)(key, value) });
        const binKey = (0, encoding_1.toAscii)(key);
        const binValue = (0, encoding_1.toAscii)(value);
        const queryParams = { path: "/key", data: binKey, prove: true };
        const response = await client.abciQuery(queryParams);
        expect(response.key).toEqual(binKey);
        expect(response.value).toEqual(binValue);
        expect(response.code).toBeFalsy();
        client.disconnect();
    });
    it("can get a commit", async () => {
        var _a, _b;
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const response = await client.commit(4);
        expect(response).toBeTruthy();
        expect(response.commit.signatures.length).toBeGreaterThanOrEqual(1);
        expect(response.commit.signatures[0].blockIdFlag).toEqual(2);
        expect((_a = response.commit.signatures[0].validatorAddress) === null || _a === void 0 ? void 0 : _a.length).toEqual(20);
        expect(response.commit.signatures[0].timestamp).toBeInstanceOf(Date);
        expect((_b = response.commit.signatures[0].signature) === null || _b === void 0 ? void 0 : _b.length).toEqual(64);
        client.disconnect();
    });
    it("can get validators", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const response = await client.validators({});
        expect(response).toBeTruthy();
        expect(response.blockHeight).toBeGreaterThanOrEqual(1);
        expect(response.count).toBeGreaterThanOrEqual(1);
        expect(response.total).toBeGreaterThanOrEqual(1);
        expect(response.validators.length).toBeGreaterThanOrEqual(1);
        expect(response.validators[0].address.length).toEqual(20);
        expect(response.validators[0].pubkey).toBeDefined();
        expect(response.validators[0].votingPower).toBeGreaterThanOrEqual(0);
        expect(response.validators[0].proposerPriority).toBeGreaterThanOrEqual(0);
        client.disconnect();
    });
    it("can get all validators", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const response = await client.validatorsAll();
        expect(response).toBeTruthy();
        expect(response.blockHeight).toBeGreaterThanOrEqual(1);
        expect(response.count).toBeGreaterThanOrEqual(1);
        expect(response.total).toBeGreaterThanOrEqual(1);
        expect(response.validators.length).toBeGreaterThanOrEqual(1);
        expect(response.validators[0].address.length).toEqual(20);
        expect(response.validators[0].pubkey).toBeDefined();
        expect(response.validators[0].votingPower).toBeGreaterThanOrEqual(0);
        expect(response.validators[0].proposerPriority).toBeGreaterThanOrEqual(0);
        client.disconnect();
    });
    it("can call a bunch of methods", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        expect(await client.block()).toBeTruthy();
        expect(await client.genesis()).toBeTruthy();
        expect(await client.health()).toBeNull();
        client.disconnect();
    });
    describe("status", () => {
        it("works", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const status = await client.status();
            // node info
            expect(status.nodeInfo.version).toMatch(expected.version);
            expect(status.nodeInfo.protocolVersion).toEqual({
                p2p: expected.p2pVersion,
                block: expected.blockVersion,
                app: expected.appVersion,
            });
            expect(status.nodeInfo.network).toMatch(testutil_spec_1.chainIdMatcher);
            expect(status.nodeInfo.other.size).toBeGreaterThanOrEqual(2);
            expect(status.nodeInfo.other.get("tx_index")).toEqual("on");
            // sync info
            expect(status.syncInfo.catchingUp).toEqual(false);
            expect(status.syncInfo.latestBlockHeight).toBeGreaterThanOrEqual(1);
            // validator info
            expect(status.validatorInfo.pubkey).toBeTruthy();
            expect(status.validatorInfo.votingPower).toBeGreaterThan(0);
            client.disconnect();
        });
    });
    describe("numUnconfirmedTxs", () => {
        it("works", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const response = await client.numUnconfirmedTxs();
            expect(response.total).toBeGreaterThanOrEqual(0);
            expect(response.totalBytes).toBeGreaterThanOrEqual(0);
            client.disconnect();
        });
    });
    describe("blockResults", () => {
        it("works", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const height = 3;
            const results = await client.blockResults(height);
            expect(results.height).toEqual(height);
            expect(results.results).toEqual([]);
            expect(results.beginBlockEvents).toEqual([]);
            expect(results.endBlockEvents).toEqual([]);
            client.disconnect();
        });
    });
    describe("blockSearch", () => {
        beforeAll(async () => {
            if ((0, testutil_spec_1.tendermintEnabled)()) {
                const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
                // eslint-disable-next-line no-inner-declarations
                async function sendTx() {
                    const tx = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
                    const txRes = await client.broadcastTxCommit({ tx: tx });
                    expect(responses.broadcastTxCommitSuccess(txRes)).toEqual(true);
                    expect(txRes.height).toBeTruthy();
                    expect(txRes.hash.length).not.toEqual(0);
                }
                // send 3 txs
                await sendTx();
                await sendTx();
                await sendTx();
                client.disconnect();
                await (0, testutil_spec_1.tendermintSearchIndexUpdated)();
            }
        });
        it("can paginate over blockSearch results", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const query = (0, requests_1.buildQuery)({ raw: "block.height >= 1 AND block.height <= 3" });
            // expect one page of results
            const s1 = await client.blockSearch({ query: query, page: 1, per_page: 2 });
            expect(s1.totalCount).toEqual(3);
            expect(s1.blocks.length).toEqual(2);
            // second page
            const s2 = await client.blockSearch({ query: query, page: 2, per_page: 2 });
            expect(s2.totalCount).toEqual(3);
            expect(s2.blocks.length).toEqual(1);
            client.disconnect();
        });
        it("can get all search results in one call", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const query = (0, requests_1.buildQuery)({ raw: "block.height >= 1 AND block.height <= 3" });
            const sall = await client.blockSearchAll({ query: query, per_page: 2 });
            expect(sall.totalCount).toEqual(3);
            expect(sall.blocks.length).toEqual(3);
            // make sure there are in order from lowest to highest height
            const [b1, b2, b3] = sall.blocks;
            expect(b2.block.header.height).toEqual(b1.block.header.height + 1);
            expect(b3.block.header.height).toEqual(b2.block.header.height + 1);
            client.disconnect();
        });
    });
    describe("blockchain", () => {
        it("returns latest in descending order by default", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            // Run in parallel to increase chance there is no block between the calls
            const [status, blockchain] = await Promise.all([client.status(), client.blockchain()]);
            const height = status.syncInfo.latestBlockHeight;
            expect(blockchain.lastHeight).toEqual(height);
            expect(blockchain.blockMetas.length).toBeGreaterThanOrEqual(3);
            expect(blockchain.blockMetas[0].header.height).toEqual(height);
            expect(blockchain.blockMetas[1].header.height).toEqual(height - 1);
            expect(blockchain.blockMetas[2].header.height).toEqual(height - 2);
            client.disconnect();
        });
        it("can limit by maxHeight", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const height = (await client.status()).syncInfo.latestBlockHeight;
            const blockchain = await client.blockchain(undefined, height - 1);
            expect(blockchain.lastHeight).toEqual(height);
            expect(blockchain.blockMetas.length).toBeGreaterThanOrEqual(2);
            expect(blockchain.blockMetas[0].header.height).toEqual(height - 1); // upper limit included
            expect(blockchain.blockMetas[1].header.height).toEqual(height - 2);
            client.disconnect();
        });
        it("works with maxHeight in the future", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const height = (await client.status()).syncInfo.latestBlockHeight;
            const blockchain = await client.blockchain(undefined, height + 20);
            expect(blockchain.lastHeight).toEqual(height);
            expect(blockchain.blockMetas.length).toBeGreaterThanOrEqual(2);
            expect(blockchain.blockMetas[0].header.height).toEqual(height);
            expect(blockchain.blockMetas[1].header.height).toEqual(height - 1);
            client.disconnect();
        });
        it("can limit by minHeight and maxHeight", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const height = (await client.status()).syncInfo.latestBlockHeight;
            const blockchain = await client.blockchain(height - 2, height - 1);
            expect(blockchain.lastHeight).toEqual(height);
            expect(blockchain.blockMetas.length).toEqual(2);
            expect(blockchain.blockMetas[0].header.height).toEqual(height - 1); // upper limit included
            expect(blockchain.blockMetas[1].header.height).toEqual(height - 2); // lower limit included
            client.disconnect();
        });
        it("contains all the info", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const height = (await client.status()).syncInfo.latestBlockHeight;
            const blockchain = await client.blockchain(height - 1, height - 1);
            expect(blockchain.lastHeight).toEqual(height);
            expect(blockchain.blockMetas.length).toBeGreaterThanOrEqual(1);
            const meta = blockchain.blockMetas[0];
            expect(meta.blockId).toEqual(jasmine.objectContaining({}));
            expect(meta.blockSize).toBeInstanceOf(Number);
            expect(meta.header).toEqual(jasmine.objectContaining({
                version: {
                    block: expected.blockVersion,
                    app: expected.appVersion,
                },
                chainId: jasmine.stringMatching(testutil_spec_1.chainIdMatcher),
            }));
            expect(meta.numTxs).toBeInstanceOf(Number);
            client.disconnect();
        });
    });
    describe("tx", () => {
        it("can query a tx properly", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const find = (0, testutil_spec_1.randomString)();
            const me = (0, testutil_spec_1.randomString)();
            const tx = (0, testutil_spec_1.buildKvTx)(find, me);
            const txRes = await client.broadcastTxCommit({ tx: tx });
            expect(responses.broadcastTxCommitSuccess(txRes)).toEqual(true);
            expect(txRes.height).toBeTruthy();
            const height = txRes.height || 0; // || 0 for type system
            expect(txRes.hash.length).not.toEqual(0);
            const hash = txRes.hash;
            await (0, testutil_spec_1.tendermintSearchIndexUpdated)();
            // find by hash - does it match?
            const r = await client.tx({ hash: hash, prove: true });
            // both values come from rpc, so same type (Buffer/Uint8Array)
            expect(r.hash).toEqual(hash);
            // force the type when comparing to locally generated value
            expect(r.tx).toEqual(tx);
            expect(r.height).toEqual(height);
            expect(r.proof).toBeTruthy();
            // txSearch - you must enable the indexer when running
            // tendermint, else you get empty results
            const query = (0, requests_1.buildQuery)({ tags: [{ key: "app.key", value: find }] });
            const s = await client.txSearch({ query: query, page: 1, per_page: 30 });
            // should find the tx
            expect(s.totalCount).toEqual(1);
            // should return same info as querying directly,
            // except without the proof
            expect(s.txs[0]).toEqual({ ...r, proof: undefined });
            // ensure txSearchAll works as well
            const sall = await client.txSearchAll({ query: query });
            // should find the tx
            expect(sall.totalCount).toEqual(1);
            // should return same info as querying directly,
            // except without the proof
            expect(sall.txs[0]).toEqual({ ...r, proof: undefined });
            // and let's query the block itself to see this transaction
            const block = await client.block(height);
            expect(block.block.txs.length).toEqual(1);
            expect(block.block.txs[0]).toEqual(tx);
            client.disconnect();
        });
    });
    describe("txSearch", () => {
        const key = (0, testutil_spec_1.randomString)();
        beforeAll(async () => {
            if ((0, testutil_spec_1.tendermintEnabled)()) {
                const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
                // eslint-disable-next-line no-inner-declarations
                async function sendTx() {
                    const me = (0, testutil_spec_1.randomString)();
                    const tx = (0, testutil_spec_1.buildKvTx)(key, me);
                    const txRes = await client.broadcastTxCommit({ tx: tx });
                    expect(responses.broadcastTxCommitSuccess(txRes)).toEqual(true);
                    expect(txRes.height).toBeTruthy();
                    expect(txRes.hash.length).not.toEqual(0);
                }
                // send 3 txs
                await sendTx();
                await sendTx();
                await sendTx();
                client.disconnect();
                await (0, testutil_spec_1.tendermintSearchIndexUpdated)();
            }
        });
        it("returns transactions in ascending order by default", async () => {
            // NOTE: The Tendermint docs claim the default ordering is "desc" but it is actually "asc"
            // Docs: https://docs.tendermint.com/master/rpc/#/Info/tx_search
            // Code: https://github.com/tendermint/tendermint/blob/v0.34.10/rpc/core/tx.go#L89
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const query = (0, requests_1.buildQuery)({ tags: [{ key: "app.key", value: key }] });
            const s = await client.txSearch({ query: query });
            expect(s.totalCount).toEqual(3);
            s.txs.slice(1).reduce((lastHeight, { height }) => {
                expect(height).toBeGreaterThanOrEqual(lastHeight);
                return height;
            }, s.txs[0].height);
            client.disconnect();
        });
        it("can set the order", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const query = (0, requests_1.buildQuery)({ tags: [{ key: "app.key", value: key }] });
            const s1 = await client.txSearch({ query: query, order_by: "desc" });
            const s2 = await client.txSearch({ query: query, order_by: "asc" });
            expect(s1.totalCount).toEqual(s2.totalCount);
            expect([...s1.txs].reverse()).toEqual(s2.txs);
            client.disconnect();
        });
        it("can paginate over txSearch results", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const query = (0, requests_1.buildQuery)({ tags: [{ key: "app.key", value: key }] });
            // expect one page of results
            const s1 = await client.txSearch({ query: query, page: 1, per_page: 2 });
            expect(s1.totalCount).toEqual(3);
            expect(s1.txs.length).toEqual(2);
            // second page
            const s2 = await client.txSearch({ query: query, page: 2, per_page: 2 });
            expect(s2.totalCount).toEqual(3);
            expect(s2.txs.length).toEqual(1);
            client.disconnect();
        });
        it("can get all search results in one call", async () => {
            (0, testutil_spec_1.pendingWithoutTendermint)();
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const query = (0, requests_1.buildQuery)({ tags: [{ key: "app.key", value: key }] });
            const sall = await client.txSearchAll({ query: query, per_page: 2 });
            expect(sall.totalCount).toEqual(3);
            expect(sall.txs.length).toEqual(3);
            // make sure there are in order from lowest to highest height
            const [tx1, tx2, tx3] = sall.txs;
            expect(tx2.height).toEqual(tx1.height + 1);
            expect(tx3.height).toEqual(tx2.height + 1);
            client.disconnect();
        });
    });
}
function websocketTestSuite(rpcFactory, expected) {
    it("can subscribe to block header events", (done) => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const testStart = readonly_date_1.ReadonlyDate.now();
        (async () => {
            const events = [];
            const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
            const stream = client.subscribeNewBlockHeader();
            expect(stream).toBeTruthy();
            const subscription = stream.subscribe({
                next: (event) => {
                    expect(event.chainId).toMatch(testutil_spec_1.chainIdMatcher);
                    expect(event.height).toBeGreaterThan(0);
                    // seems that tendermint just guarantees within the last second for timestamp
                    expect(event.time.getTime()).toBeGreaterThan(testStart - 1000);
                    // Tendermint clock is sometimes ahead of test clock. Add 10ms tolerance
                    expect(event.time.getTime()).toBeLessThanOrEqual(readonly_date_1.ReadonlyDate.now() + 10);
                    expect(event.lastBlockId).toBeTruthy();
                    // merkle roots for proofs
                    expect(event.appHash).toBeTruthy();
                    expect(event.consensusHash).toBeTruthy();
                    expect(event.dataHash).toBeTruthy();
                    expect(event.evidenceHash).toBeTruthy();
                    expect(event.lastCommitHash).toBeTruthy();
                    expect(event.lastResultsHash).toBeTruthy();
                    expect(event.validatorsHash).toBeTruthy();
                    events.push(event);
                    if (events.length === 2) {
                        subscription.unsubscribe();
                        expect(events.length).toEqual(2);
                        expect(events[1].chainId).toEqual(events[0].chainId);
                        expect(events[1].height).toEqual(events[0].height + 1);
                        expect(events[1].time.getTime()).toBeGreaterThan(events[0].time.getTime());
                        expect(events[1].appHash).toEqual(events[0].appHash);
                        expect(events[1].consensusHash).toEqual(events[0].consensusHash);
                        expect(events[1].dataHash).toEqual(events[0].dataHash);
                        expect(events[1].evidenceHash).toEqual(events[0].evidenceHash);
                        expect(events[1].lastCommitHash).not.toEqual(events[0].lastCommitHash);
                        expect(events[1].lastResultsHash).not.toEqual(events[0].lastResultsHash);
                        expect(events[1].validatorsHash).toEqual(events[0].validatorsHash);
                        client.disconnect();
                        done();
                    }
                },
                error: done.fail,
                complete: () => done.fail("Stream completed before we are done"),
            });
        })().catch(done.fail);
    });
    it("can subscribe to block events", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const testStart = readonly_date_1.ReadonlyDate.now();
        const transactionData1 = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        const transactionData2 = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        const events = [];
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const stream = client.subscribeNewBlock();
        const subscription = stream.subscribe({
            next: (event) => {
                expect(event.header.chainId).toMatch(testutil_spec_1.chainIdMatcher);
                expect(event.header.height).toBeGreaterThan(0);
                // seems that tendermint just guarantees within the last second for timestamp
                expect(event.header.time.getTime()).toBeGreaterThan(testStart - 1000);
                // Tendermint clock is sometimes ahead of test clock. Add 10ms tolerance
                expect(event.header.time.getTime()).toBeLessThanOrEqual(readonly_date_1.ReadonlyDate.now() + 10);
                expect(event.header.lastBlockId).toBeTruthy();
                // merkle roots for proofs
                expect(event.header.appHash).toBeTruthy();
                expect(event.header.consensusHash).toBeTruthy();
                expect(event.header.dataHash).toBeTruthy();
                expect(event.header.evidenceHash).toBeTruthy();
                expect(event.header.lastCommitHash).toBeTruthy();
                expect(event.header.lastResultsHash).toBeTruthy();
                expect(event.header.validatorsHash).toBeTruthy();
                events.push(event);
                if (events.length === 2) {
                    subscription.unsubscribe();
                }
            },
            error: fail,
        });
        await client.broadcastTxCommit({ tx: transactionData1 });
        await client.broadcastTxCommit({ tx: transactionData2 });
        // wait for events to be processed
        await (0, utils_1.sleep)(100);
        expect(events.length).toEqual(2);
        // Block header
        expect(events[1].header.height).toEqual(events[0].header.height + 1);
        expect(events[1].header.chainId).toEqual(events[0].header.chainId);
        expect(events[1].header.time.getTime()).toBeGreaterThan(events[0].header.time.getTime());
        expect(events[1].header.appHash).not.toEqual(events[0].header.appHash);
        expect(events[1].header.validatorsHash).toEqual(events[0].header.validatorsHash);
        // Block body
        expect(events[0].txs.length).toEqual(1);
        expect(events[1].txs.length).toEqual(1);
        expect(events[0].txs[0]).toEqual(transactionData1);
        expect(events[1].txs[0]).toEqual(transactionData2);
        client.disconnect();
    });
    it("can subscribe to transaction events", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const events = [];
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const stream = client.subscribeTx();
        const subscription = stream.subscribe({
            next: (event) => {
                expect(event.height).toBeGreaterThan(0);
                expect(event.result).toBeTruthy();
                expect(event.result.events.length).toBeGreaterThanOrEqual(1);
                events.push(event);
                if (events.length === 2) {
                    subscription.unsubscribe();
                }
            },
            error: fail,
        });
        const transactionData1 = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        const transactionData2 = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        await client.broadcastTxCommit({ tx: transactionData1 });
        await client.broadcastTxCommit({ tx: transactionData2 });
        // wait for events to be processed
        await (0, utils_1.sleep)(100);
        expect(events.length).toEqual(2);
        // Meta
        expect(events[1].height).toEqual(events[0].height + 1);
        expect(events[1].result.events).not.toEqual(events[0].result.events);
        // Content
        expect(events[0].tx).toEqual(transactionData1);
        expect(events[1].tx).toEqual(transactionData2);
        client.disconnect();
    });
    it("can subscribe to transaction events filtered by creator", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const transactionData1 = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        const transactionData2 = (0, testutil_spec_1.buildKvTx)((0, testutil_spec_1.randomString)(), (0, testutil_spec_1.randomString)());
        const events = [];
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const query = (0, requests_1.buildQuery)({ tags: [{ key: "app.creator", value: expected.appCreator }] });
        const stream = client.subscribeTx(query);
        expect(stream).toBeTruthy();
        const subscription = stream.subscribe({
            next: (event) => {
                expect(event.height).toBeGreaterThan(0);
                expect(event.result).toBeTruthy();
                expect(event.result.events.length).toBeGreaterThanOrEqual(1);
                events.push(event);
                if (events.length === 2) {
                    subscription.unsubscribe();
                }
            },
            error: fail,
        });
        await client.broadcastTxCommit({ tx: transactionData1 });
        await client.broadcastTxCommit({ tx: transactionData2 });
        // wait for events to be processed
        await (0, utils_1.sleep)(100);
        expect(events.length).toEqual(2);
        // Meta
        expect(events[1].height).toEqual(events[0].height + 1);
        expect(events[1].result.events).not.toEqual(events[0].result.events);
        // Content
        expect(events[0].tx).toEqual(transactionData1);
        expect(events[1].tx).toEqual(transactionData2);
        client.disconnect();
    });
    it("can unsubscribe and re-subscribe to the same stream", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const stream = client.subscribeNewBlockHeader();
        const event1 = await (0, stream_1.firstEvent)(stream);
        expect(event1.height).toBeGreaterThanOrEqual(1);
        expect(event1.time.getTime()).toBeGreaterThanOrEqual(1);
        // No sleep: producer will not be stopped in the meantime
        const event2 = await (0, stream_1.firstEvent)(stream);
        expect(event2.height).toBeGreaterThan(event1.height);
        expect(event2.time.getTime()).toBeGreaterThan(event1.time.getTime());
        // Very short sleep: just enough to schedule asynchronous producer stopping
        await (0, utils_1.sleep)(5);
        const event3 = await (0, stream_1.firstEvent)(stream);
        expect(event3.height).toBeGreaterThan(event2.height);
        expect(event3.time.getTime()).toBeGreaterThan(event2.time.getTime());
        // Proper sleep: enough to finish unsubscribing at over the network
        await (0, utils_1.sleep)(100);
        const event4 = await (0, stream_1.firstEvent)(stream);
        expect(event4.height).toBeGreaterThan(event3.height);
        expect(event4.time.getTime()).toBeGreaterThan(event3.time.getTime());
        client.disconnect();
    });
    it("can subscribe twice", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        const client = await tendermint34client_1.Tendermint34Client.create(rpcFactory());
        const stream1 = client.subscribeNewBlockHeader();
        const stream2 = client.subscribeNewBlockHeader();
        const events = await (0, stream_1.toListPromise)(xstream_1.Stream.merge(stream1, stream2), 4);
        expect(new Set(events.map((e) => e.height)).size).toEqual(2);
        client.disconnect();
    });
}
describe("Tendermint34Client", () => {
    const { url, expected } = testutil_spec_1.tendermintInstances[0];
    it("can connect to a given url", async () => {
        (0, testutil_spec_1.pendingWithoutTendermint)();
        // default connection
        {
            const client = await tendermint34client_1.Tendermint34Client.connect(url);
            const info = await client.abciInfo();
            expect(info).toBeTruthy();
            client.disconnect();
        }
        // http connection
        {
            const client = await tendermint34client_1.Tendermint34Client.connect("http://" + url);
            const info = await client.abciInfo();
            expect(info).toBeTruthy();
            client.disconnect();
        }
        // ws connection
        {
            const client = await tendermint34client_1.Tendermint34Client.connect("ws://" + url);
            const info = await client.abciInfo();
            expect(info).toBeTruthy();
            client.disconnect();
        }
    });
    describe("With HttpClient", () => {
        defaultTestSuite(() => new rpcclients_1.HttpClient(url), expected);
    });
    describe("With WebsocketClient", () => {
        // don't print out WebSocket errors if marked pending
        const onError = process.env.TENDERMINT_ENABLED ? console.error : () => 0;
        const factory = () => new rpcclients_1.WebsocketClient(url, onError);
        defaultTestSuite(factory, expected);
        websocketTestSuite(factory, expected);
    });
});
//# sourceMappingURL=tendermint34client.spec.js.map