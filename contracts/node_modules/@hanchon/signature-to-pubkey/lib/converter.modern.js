import{fromRpcSig as t,setLengthLeft as e}from"@ethereumjs/util";import n from"crypto";function r(t){var e={exports:{}};return t(e,e.exports),e.exports}var i=r(function(t,e){function n(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function r(t){if("boolean"!=typeof t)throw new Error(`Expected boolean, not ${t}`)}function i(t,...e){if(!(t instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new TypeError(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function o(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");n(t.outputLen),n(t.blockLen)}function s(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function a(t,e){i(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}Object.defineProperty(e,"__esModule",{value:!0}),e.output=e.exists=e.hash=e.bytes=e.bool=e.number=void 0,e.number=n,e.bool=r,e.bytes=i,e.hash=o,e.exists=s,e.output=a,e.default={number:n,bool:r,bytes:i,hash:o,exists:s,output:a}});r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto={node:n,web:void 0}});var o=r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.crypto=void 0,e.crypto={node:void 0,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0}}),s=r(function(t,e){if(Object.defineProperty(e,"__esModule",{value:!0}),e.randomBytes=e.wrapConstructorWithOpts=e.wrapConstructor=e.checkOpts=e.Hash=e.concatBytes=e.toBytes=e.utf8ToBytes=e.asyncLoop=e.nextTick=e.hexToBytes=e.bytesToHex=e.isLE=e.rotr=e.createView=e.u32=e.u8=void 0,e.u8=t=>new Uint8Array(t.buffer,t.byteOffset,t.byteLength),e.u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),e.createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),e.rotr=(t,e)=>t<<32-e|t>>>e,e.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!e.isLE)throw new Error("Non little-endian hardware is not supported");const n=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function r(t){if("string"!=typeof t)throw new TypeError("utf8ToBytes expected string, got "+typeof t);return(new TextEncoder).encode(t)}function i(t){if("string"==typeof t&&(t=r(t)),!(t instanceof Uint8Array))throw new TypeError(`Expected input type is Uint8Array (got ${typeof t})`);return t}e.bytesToHex=function(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected");let e="";for(let r=0;r<t.length;r++)e+=n[t[r]];return e},e.hexToBytes=function(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex");const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e},e.nextTick=async()=>{},e.asyncLoop=async function(t,n,r){let i=Date.now();for(let o=0;o<t;o++){r(o);const t=Date.now()-i;t>=0&&t<n||(await(0,e.nextTick)(),i+=t)}},e.utf8ToBytes=r,e.toBytes=i,e.concatBytes=function(...t){if(!t.every(t=>t instanceof Uint8Array))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce((t,e)=>t+e.length,0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n},e.Hash=class{clone(){return this._cloneInto()}},e.checkOpts=function(t,e){if(void 0!==e&&("object"!=typeof e||(n=e,"[object Object]"!==Object.prototype.toString.call(n)||n.constructor!==Object)))throw new TypeError("Options should be object or undefined");var n;return Object.assign(t,e)},e.wrapConstructor=function(t){const e=e=>t().update(i(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e},e.wrapConstructorWithOpts=function(t){const e=(e,n)=>t(n).update(i(e)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=e=>t(e),e},e.randomBytes=function(t=32){if(o.crypto.web)return o.crypto.web.getRandomValues(new Uint8Array(t));if(o.crypto.node)return new Uint8Array(o.crypto.node.randomBytes(t).buffer);throw new Error("The environment doesn't have randomBytes function")}}),a=r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.hmac=void 0;class n extends s.Hash{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,i.default.hash(t);const n=(0,s.toBytes)(e);if(this.iHash=t.create(),!(this.iHash instanceof s.Hash))throw new TypeError("Expected instance of class which extends utils.Hash");const r=this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const o=new Uint8Array(r);o.set(n.length>this.iHash.blockLen?t.create().update(n).digest():n);for(let t=0;t<o.length;t++)o[t]^=54;this.iHash.update(o),this.oHash=t.create();for(let t=0;t<o.length;t++)o[t]^=106;this.oHash.update(o),o.fill(0)}update(t){return i.default.exists(this),this.iHash.update(t),this}digestInto(t){i.default.exists(this),i.default.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:i,blockLen:o,outputLen:s}=this;return(t=t).finished=r,t.destroyed=i,t.blockLen=o,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}e.hmac=(t,e,r)=>new n(t,e).update(r).digest(),e.hmac.create=(t,e)=>new n(t,e)}),c=r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.SHA2=void 0,e.SHA2=class extends s.Hash{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=(0,s.createView)(this.buffer)}update(t){i.default.exists(this);const{view:e,buffer:n,blockLen:r}=this,o=(t=(0,s.toBytes)(t)).length;for(let i=0;i<o;){const a=Math.min(r-this.pos,o-i);if(a!==r)n.set(t.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===r&&(this.process(e,0),this.pos=0);else{const e=(0,s.createView)(t);for(;r<=o-i;i+=r)this.process(e,i)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){i.default.exists(this),i.default.output(t,this),this.finished=!0;const{buffer:e,view:n,blockLen:r,isLE:o}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>r-a&&(this.process(n,0),a=0);for(let t=a;t<r;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const i=BigInt(32),o=BigInt(4294967295),s=Number(n>>i&o),a=Number(n&o),c=r?0:4;t.setUint32(e+(r?4:0),s,r),t.setUint32(e+c,a,r)}(n,r-8,BigInt(8*this.length),o),this.process(n,0);const c=(0,s.createView)(t);this.get().forEach((t,e)=>c.setUint32(4*e,t,o))}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:i,destroyed:o,pos:s}=this;return t.length=r,t.pos=s,t.finished=i,t.destroyed=o,r%e&&t.buffer.set(n),t}}}),u=r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.sha256=void 0;const n=(t,e,n)=>t&e^t&n^e&n,r=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),i=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),o=new Uint32Array(64);class a extends c.SHA2{constructor(){super(64,32,8,!1),this.A=0|i[0],this.B=0|i[1],this.C=0|i[2],this.D=0|i[3],this.E=0|i[4],this.F=0|i[5],this.G=0|i[6],this.H=0|i[7]}get(){const{A:t,B:e,C:n,D:r,E:i,F:o,G:s,H:a}=this;return[t,e,n,r,i,o,s,a]}set(t,e,n,r,i,o,s,a){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(t,e){for(let n=0;n<16;n++,e+=4)o[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=o[t-15],n=o[t-2],r=(0,s.rotr)(e,7)^(0,s.rotr)(e,18)^e>>>3,i=(0,s.rotr)(n,17)^(0,s.rotr)(n,19)^n>>>10;o[t]=i+o[t-7]+r+o[t-16]|0}let{A:i,B:a,C:c,D:u,E:h,F:f,G:l,H:d}=this;for(let t=0;t<64;t++){const e=d+((0,s.rotr)(h,6)^(0,s.rotr)(h,11)^(0,s.rotr)(h,25))+((y=h)&f^~y&l)+r[t]+o[t]|0,g=((0,s.rotr)(i,2)^(0,s.rotr)(i,13)^(0,s.rotr)(i,22))+n(i,a,c)|0;d=l,l=f,f=h,h=u+e|0,u=c,c=a,a=i,i=e+g|0}var y;i=i+this.A|0,a=a+this.B|0,c=c+this.C|0,u=u+this.D|0,h=h+this.E|0,f=f+this.F|0,l=l+this.G|0,d=d+this.H|0,this.set(i,a,c,u,h,f,l,d)}roundClean(){o.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}e.sha256=(0,s.wrapConstructor)(()=>new a)}),h={__proto__:null,default:{}},f=r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.utils=e.schnorr=e.verify=e.signSync=e.sign=e.getSharedSecret=e.recoverPublicKey=e.getPublicKey=e.Signature=e.Point=e.CURVE=void 0;const n=BigInt(0),r=BigInt(1),i=BigInt(2),o=BigInt(3),s=BigInt(8),a=i**BigInt(256),c={a:n,b:BigInt(7),P:a-i**BigInt(32)-BigInt(977),n:a-BigInt("432420386565659656852420866394968145599"),h:r,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")};function u(t){const{a:e,b:n}=c,r=k(t*t),i=k(r*t);return k(i+e*t+n)}e.CURVE=c;const f=c.a===n;class l{constructor(t,e,n){this.x=t,this.y=e,this.z=n}static fromAffine(t){if(!(t instanceof y))throw new TypeError("JacobianPoint#fromAffine: expected Point");return new l(t.x,t.y,r)}static toAffineBatch(t){const e=function(t,e=c.P){const i=new Array(t.length),o=T(t.reduce((t,r,o)=>r===n?t:(i[o]=t,k(t*r,e)),r),e);return t.reduceRight((t,r,o)=>r===n?t:(i[o]=k(t*i[o],e),k(t*r,e)),o),i}(t.map(t=>t.z));return t.map((t,n)=>t.toAffine(e[n]))}static normalizeZ(t){return l.toAffineBatch(t).map(l.fromAffine)}equals(t){if(!(t instanceof l))throw new TypeError("JacobianPoint expected");const{x:e,y:n,z:r}=this,{x:o,y:s,z:a}=t,c=k(r**i),u=k(a**i),h=k(e*u),f=k(o*c),d=k(k(n*a)*u),y=k(k(s*r)*c);return h===f&&d===y}negate(){return new l(this.x,k(-this.y),this.z)}double(){const{x:t,y:e,z:n}=this,r=k(t**i),a=k(e**i),c=k(a**i),u=k(i*(k((t+a)**i)-r-c)),h=k(o*r),f=k(h**i),d=k(f-i*u),y=k(h*(u-d)-s*c),g=k(i*e*n);return new l(d,y,g)}add(t){if(!(t instanceof l))throw new TypeError("JacobianPoint expected");const{x:e,y:r,z:o}=this,{x:s,y:a,z:c}=t;if(s===n||a===n)return this;if(e===n||r===n)return t;const u=k(o**i),h=k(c**i),f=k(e*h),d=k(s*u),y=k(k(r*c)*h),g=k(k(a*o)*u),w=k(d-f),p=k(g-y);if(w===n)return p===n?this.double():l.ZERO;const m=k(w**i),b=k(w*m),E=k(f*m),v=k(p**i-b-i*E),x=k(p*(E-v)-y*b),A=k(o*c*w);return new l(v,x,A)}subtract(t){return this.add(t.negate())}multiplyUnsafe(t){const e=l.ZERO;if("bigint"==typeof t&&t===n)return e;let i=P(t);if(i===r)return this;if(!f){let t=e,o=this;for(;i>n;)i&r&&(t=t.add(o)),o=o.double(),i>>=r;return t}let{k1neg:o,k1:s,k2neg:a,k2:u}=C(i),h=e,d=e,y=this;for(;s>n||u>n;)s&r&&(h=h.add(y)),u&r&&(d=d.add(y)),y=y.double(),s>>=r,u>>=r;return o&&(h=h.negate()),a&&(d=d.negate()),d=new l(k(d.x*c.beta),d.y,d.z),h.add(d)}precomputeWindow(t){const e=f?128/t+1:256/t+1,n=[];let r=this,i=r;for(let o=0;o<e;o++){i=r,n.push(i);for(let e=1;e<2**(t-1);e++)i=i.add(r),n.push(i);r=i.double()}return n}wNAF(t,e){!e&&this.equals(l.BASE)&&(e=y.BASE);const n=e&&e._WINDOW_SIZE||1;if(256%n)throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");let i=e&&d.get(e);i||(i=this.precomputeWindow(n),e&&1!==n&&(i=l.normalizeZ(i),d.set(e,i)));let o=l.ZERO,s=l.ZERO;const a=1+(f?128/n:256/n),c=2**(n-1),u=BigInt(2**n-1),h=2**n,g=BigInt(n);for(let e=0;e<a;e++){const n=e*c;let a=Number(t&u);if(t>>=g,a>c&&(a-=h,t+=r),0===a){let t=i[n];e%2&&(t=t.negate()),s=s.add(t)}else{let t=i[n+Math.abs(a)-1];a<0&&(t=t.negate()),o=o.add(t)}}return{p:o,f:s}}multiply(t,e){let n,r,i=P(t);if(f){const{k1neg:t,k1:o,k2neg:s,k2:a}=C(i);let{p:u,f:h}=this.wNAF(o,e),{p:f,f:d}=this.wNAF(a,e);t&&(u=u.negate()),s&&(f=f.negate()),f=new l(k(f.x*c.beta),f.y,f.z),n=u.add(f),r=h.add(d)}else{const{p:t,f:o}=this.wNAF(i,e);n=t,r=o}return l.normalizeZ([n,r])[0]}toAffine(t=T(this.z)){const{x:e,y:n,z:i}=this,o=t,s=k(o*o),a=k(s*o),c=k(e*s),u=k(n*a);if(k(i*o)!==r)throw new Error("invZ was invalid");return new y(c,u)}}l.BASE=new l(c.Gx,c.Gy,r),l.ZERO=new l(n,r,n);const d=new WeakMap;class y{constructor(t,e){this.x=t,this.y=e}_setWindowSize(t){this._WINDOW_SIZE=t,d.delete(this)}static fromCompressedHex(t){const e=32===t.length,n=I(e?t:t.subarray(1));if(!N(n))throw new Error("Point is not on curve");let s=function(t){const{P:e}=c,n=BigInt(6),r=BigInt(11),s=BigInt(22),a=BigInt(23),u=BigInt(44),h=BigInt(88),f=t*t*t%e,l=f*f*t%e,d=R(l,o)*l%e,y=R(d,o)*l%e,g=R(y,i)*f%e,w=R(g,r)*g%e,p=R(w,s)*w%e,m=R(p,u)*p%e,b=R(m,h)*m%e,E=R(b,u)*p%e,v=R(E,o)*l%e,x=R(v,a)*w%e,A=R(x,n)*f%e;return R(A,i)}(u(n));const a=(s&r)===r;e?a&&(s=k(-s)):1==(1&t[0])!==a&&(s=k(-s));const h=new y(n,s);return h.assertValidity(),h}static fromUncompressedHex(t){const e=I(t.subarray(1,33)),n=I(t.subarray(33,65)),r=new y(e,n);return r.assertValidity(),r}static fromHex(t){const e=U(t),n=e.length,r=e[0];if(32===n||33===n&&(2===r||3===r))return this.fromCompressedHex(e);if(65===n&&4===r)return this.fromUncompressedHex(e);throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${n}`)}static fromPrivateKey(t){return y.BASE.multiply(K(t))}static fromSignature(t,e,n){const r=_(t=U(t)),{r:i,s:o}=D(e);if(0!==n&&1!==n)throw new Error("Cannot recover signature: invalid recovery bit");const s=y.fromHex((1&n?"03":"02")+x(i)),{n:a}=c,u=T(i,a),h=k(-r*u,a),f=k(o*u,a),l=y.BASE.multiplyAndAddUnsafe(s,h,f);if(!l)throw new Error("Cannot recover signature: point at infinify");return l.assertValidity(),l}toRawBytes(t=!1){return H(this.toHex(t))}toHex(t=!1){const e=x(this.x);return t?`${this.y&r?"03":"02"}${e}`:`04${e}${x(this.y)}`}toHexX(){return this.toHex(!0).slice(2)}toRawX(){return this.toRawBytes(!0).slice(1)}assertValidity(){const t="Point is not on elliptic curve",{x:e,y:r}=this;if(!N(e)||!N(r))throw new Error(t);const i=k(r*r);if(k(i-u(e))!==n)throw new Error(t)}equals(t){return this.x===t.x&&this.y===t.y}negate(){return new y(this.x,k(-this.y))}double(){return l.fromAffine(this).double().toAffine()}add(t){return l.fromAffine(this).add(l.fromAffine(t)).toAffine()}subtract(t){return this.add(t.negate())}multiply(t){return l.fromAffine(this).multiply(t,this).toAffine()}multiplyAndAddUnsafe(t,e,i){const o=l.fromAffine(this),s=e===n||e===r||this!==y.BASE?o.multiplyUnsafe(e):o.multiply(e),a=l.fromAffine(t).multiplyUnsafe(i),c=s.add(a);return c.equals(l.ZERO)?void 0:c.toAffine()}}function g(t){return Number.parseInt(t[0],16)>=8?"00"+t:t}function w(t){if(t.length<2||2!==t[0])throw new Error(`Invalid signature integer tag: ${v(t)}`);const e=t[1],n=t.subarray(2,e+2);if(!e||n.length!==e)throw new Error("Invalid signature integer: wrong length");if(0===n[0]&&n[1]<=127)throw new Error("Invalid signature integer: trailing length");return{data:I(n),left:t.subarray(e+2)}}e.Point=y,y.BASE=new y(c.Gx,c.Gy),y.ZERO=new y(n,n);class p{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromCompact(t){const e=b(t),n="Signature.fromCompact";if("string"!=typeof t&&!e)throw new TypeError(`${n}: Expected string or Uint8Array`);const r=e?v(t):t;if(128!==r.length)throw new Error(`${n}: Expected 64-byte hex`);return new p(B(r.slice(0,64)),B(r.slice(64,128)))}static fromDER(t){const e=b(t);if("string"!=typeof t&&!e)throw new TypeError("Signature.fromDER: Expected string or Uint8Array");const{r:n,s:r}=function(t){if(t.length<2||48!=t[0])throw new Error(`Invalid signature tag: ${v(t)}`);if(t[1]!==t.length-2)throw new Error("Invalid signature: incorrect length");const{data:e,left:n}=w(t.subarray(2)),{data:r,left:i}=w(n);if(i.length)throw new Error(`Invalid signature: left bytes after parsing: ${v(i)}`);return{r:e,s:r}}(e?t:H(t));return new p(n,r)}static fromHex(t){return this.fromDER(t)}assertValidity(){const{r:t,s:e}=this;if(!$(t))throw new Error("Invalid Signature: r must be 0 < r < n");if(!$(e))throw new Error("Invalid Signature: s must be 0 < s < n")}hasHighS(){return this.s>c.n>>r}normalizeS(){return this.hasHighS()?new p(this.r,c.n-this.s):this}toDERRawBytes(t=!1){return H(this.toDERHex(t))}toDERHex(t=!1){const e=g(S(this.s));if(t)return e;const n=g(S(this.r)),r=S(n.length/2),i=S(e.length/2);return`30${S(n.length/2+e.length/2+4)}02${r}${n}02${i}${e}`}toRawBytes(){return this.toDERRawBytes()}toHex(){return this.toDERHex()}toCompactRawBytes(){return H(this.toCompactHex())}toCompactHex(){return x(this.r)+x(this.s)}}function m(...t){if(!t.every(b))throw new Error("Uint8Array list expected");if(1===t.length)return t[0];const e=t.reduce((t,e)=>t+e.length,0),n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const i=t[e];n.set(i,r),r+=i.length}return n}function b(t){return t instanceof Uint8Array}e.Signature=p;const E=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function v(t){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");let e="";for(let n=0;n<t.length;n++)e+=E[t[n]];return e}function x(t){if(t>a)throw new Error("Expected number < 2^256");return t.toString(16).padStart(64,"0")}function A(t){return H(x(t))}function S(t){const e=t.toString(16);return 1&e.length?`0${e}`:e}function B(t){if("string"!=typeof t)throw new TypeError("hexToNumber: expected string, got "+typeof t);return BigInt(`0x${t}`)}function H(t){if("string"!=typeof t)throw new TypeError("hexToBytes: expected string, got "+typeof t);if(t.length%2)throw new Error("hexToBytes: received invalid unpadded hex"+t.length);const e=new Uint8Array(t.length/2);for(let n=0;n<e.length;n++){const r=2*n,i=t.slice(r,r+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");e[n]=o}return e}function I(t){return B(v(t))}function U(t){return t instanceof Uint8Array?Uint8Array.from(t):H(t)}function P(t){if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)return BigInt(t);if("bigint"==typeof t&&$(t))return t;throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n")}function k(t,e=c.P){const r=t%e;return r>=n?r:e+r}function R(t,e){const{P:r}=c;let i=t;for(;e-- >n;)i*=i,i%=r;return i}function T(t,e=c.P){if(t===n||e<=n)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let i=k(t,e),o=e,s=n,a=r;for(;i!==n;){const t=o%i,e=s-a*(o/i);o=i,i=t,s=a,a=e}if(o!==r)throw new Error("invert: does not exist");return k(s,e)}const O=(t,e)=>(t+e/i)/e,L=i**BigInt(128);function C(t){const{n:e}=c,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),i=-r*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,a=O(s*t,e),u=O(-i*t,e);let h=k(t-a*n-u*o,e),f=k(-a*i-u*s,e);const l=h>L,d=f>L;if(l&&(h=e-h),d&&(f=e-f),h>L||f>L)throw new Error("splitScalarEndo: Endomorphism failed, k="+t);return{k1neg:l,k1:h,k2neg:d,k2:f}}function _(t){const{n:e}=c,n=8*t.length-256;let r=I(t);return n>0&&(r>>=BigInt(n)),r>=e&&(r-=e),r}class j{constructor(){this.v=new Uint8Array(32).fill(1),this.k=new Uint8Array(32).fill(0),this.counter=0}hmac(...t){return e.utils.hmacSha256(this.k,...t)}hmacSync(...t){if("function"!=typeof e.utils.hmacSha256Sync)throw new Error("utils.hmacSha256Sync is undefined, you need to set it");const n=e.utils.hmacSha256Sync(this.k,...t);if(n instanceof Promise)throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");return n}incr(){if(this.counter>=1e3)throw new Error("Tried 1,000 k values for sign(), all were invalid");this.counter+=1}async reseed(t=new Uint8Array){this.k=await this.hmac(this.v,Uint8Array.from([0]),t),this.v=await this.hmac(this.v),0!==t.length&&(this.k=await this.hmac(this.v,Uint8Array.from([1]),t),this.v=await this.hmac(this.v))}reseedSync(t=new Uint8Array){this.k=this.hmacSync(this.v,Uint8Array.from([0]),t),this.v=this.hmacSync(this.v),0!==t.length&&(this.k=this.hmacSync(this.v,Uint8Array.from([1]),t),this.v=this.hmacSync(this.v))}async generate(){return this.incr(),this.v=await this.hmac(this.v),this.v}generateSync(){return this.incr(),this.v=this.hmacSync(this.v),this.v}}function $(t){return n<t&&t<c.n}function N(t){return n<t&&t<c.P}function V(t,e,i){const o=I(t);if(!$(o))return;const{n:s}=c,a=y.BASE.multiply(o),u=k(a.x,s);if(u===n)return;const h=k(T(o,s)*k(e+i*u,s),s);if(h===n)return;const f=new p(u,h);return{sig:f,recovery:(a.x===f.r?0:2)|Number(a.y&r)}}function K(t){let e;if("bigint"==typeof t)e=t;else if("number"==typeof t&&Number.isSafeInteger(t)&&t>0)e=BigInt(t);else if("string"==typeof t){if(64!==t.length)throw new Error("Expected 32 bytes of private key");e=B(t)}else{if(!b(t))throw new TypeError("Expected valid private key");if(32!==t.length)throw new Error("Expected 32 bytes of private key");e=I(t)}if(!$(e))throw new Error("Expected private key: 0 < key < n");return e}function z(t){return t instanceof y?(t.assertValidity(),t):y.fromHex(t)}function D(t){if(t instanceof p)return t.assertValidity(),t;try{return p.fromDER(t)}catch(e){return p.fromCompact(t)}}function M(t){const e=b(t),n="string"==typeof t,r=(e||n)&&t.length;return e?33===r||65===r:n?66===r||130===r:t instanceof y}function W(t){return I(t.length>32?t.slice(0,32):t)}function Z(t){const e=W(t),r=k(e,c.n);return F(r<n?e:r)}function F(t){if("bigint"!=typeof t)throw new Error("Expected bigint");return H(x(t))}function G(t,n,r){if(null==t)throw new Error(`sign: expected valid message hash, not "${t}"`);const i=U(t),o=K(n),s=[F(o),Z(i)];if(null!=r){!0===r&&(r=e.utils.randomBytes(32));const t=U(r);if(32!==t.length)throw new Error("sign: Expected 32 bytes of extra data");s.push(t)}return{seed:m(...s),m:W(i),d:o}}function X(t,e){let{sig:n,recovery:r}=t;const{canonical:i,der:o,recovered:s}=Object.assign({canonical:!0,der:!0},e);i&&n.hasHighS()&&(n=n.normalizeS(),r^=1);const a=o?n.toDERRawBytes():n.toCompactRawBytes();return s?[a,r]:a}e.getPublicKey=function(t,e=!1){return y.fromPrivateKey(t).toRawBytes(e)},e.recoverPublicKey=function(t,e,n,r=!1){return y.fromSignature(t,e,n).toRawBytes(r)},e.getSharedSecret=function(t,e,n=!1){if(M(t))throw new TypeError("getSharedSecret: first arg must be private key");if(!M(e))throw new TypeError("getSharedSecret: second arg must be public key");const r=z(e);return r.assertValidity(),r.multiply(K(t)).toRawBytes(n)},e.sign=async function(t,e,n={}){const{seed:r,m:i,d:o}=G(t,e,n.extraEntropy);let s;const a=new j;for(await a.reseed(r);!(s=V(await a.generate(),i,o));)await a.reseed();return X(s,n)},e.signSync=function(t,e,n={}){const{seed:r,m:i,d:o}=G(t,e,n.extraEntropy);let s;const a=new j;for(a.reseedSync(r);!(s=V(a.generateSync(),i,o));)a.reseedSync();return X(s,n)};const q={strict:!0};function J(t){return k(I(t),c.n)}function Q(t){return(t.y&r)===n}e.verify=function(t,e,n,r=q){let i;try{i=D(t),e=U(e)}catch(t){return!1}const{r:o,s}=i;if(r.strict&&i.hasHighS())return!1;const a=_(e);let u;try{u=z(n)}catch(t){return!1}const{n:h}=c,f=T(s,h),l=k(a*f,h),d=k(o*f,h),g=y.BASE.multiplyAndAddUnsafe(u,l,d);return!!g&&k(g.x,h)===o};class Y{constructor(t,e){this.r=t,this.s=e,this.assertValidity()}static fromHex(t){const e=U(t);if(64!==e.length)throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${e.length}`);const n=I(e.subarray(0,32)),r=I(e.subarray(32,64));return new Y(n,r)}assertValidity(){const{r:t,s:e}=this;if(!N(t)||!$(e))throw new Error("Invalid signature")}toHex(){return x(this.r)+x(this.s)}toRawBytes(){return H(this.toHex())}}function tt(t,e,n){if(null==t)throw new TypeError(`sign: Expected valid message, not "${t}"`);const r=U(t),i=K(e),o=U(n);if(32!==o.length)throw new TypeError("sign: Expected 32 bytes of aux randomness");const s=y.fromPrivateKey(i),a=s.toRawX();return{m:r,P:s,px:a,d:Q(s)?i:c.n-i,rand:o}}function et(t,e){return A(t^I(e))}function nt(t){const e=k(I(t),c.n);if(e===n)throw new Error("sign: Creation of signature failed. k is zero");const r=y.fromPrivateKey(e),i=r.toRawX();return{R:r,rx:i,k:Q(r)?e:c.n-e}}function rt(t,e,n,r){return new Y(t.x,k(e+n*r,c.n)).toRawBytes()}function it(t,e,n){const r=t instanceof Y,i=r?t:Y.fromHex(t);return r&&i.assertValidity(),{...i,m:U(e),P:z(n)}}function ot(t,e,n,r){const i=y.BASE.multiplyAndAddUnsafe(e,K(n),k(-r,c.n));return!(!i||!Q(i)||i.x!==t)}async function st(t,n,r){try{const{r:i,s:o,m:s,P:a}=it(t,n,r),c=J(await e.utils.taggedHash(ut.challenge,A(i),a.toRawX(),s));return ot(i,a,o,c)}catch(t){return!1}}function at(t,n,r){try{const{r:i,s:o,m:s,P:a}=it(t,n,r),c=J(e.utils.taggedHashSync(ut.challenge,A(i),a.toRawX(),s));return ot(i,a,o,c)}catch(t){return!1}}e.schnorr={Signature:Y,getPublicKey:function(t){return y.fromPrivateKey(t).toRawX()},sign:async function(t,n,r=e.utils.randomBytes()){const{m:i,px:o,d:s,rand:a}=tt(t,n,r),c=et(s,await e.utils.taggedHash(ut.aux,a)),{R:u,rx:h,k:f}=nt(await e.utils.taggedHash(ut.nonce,c,o,i)),l=rt(u,f,J(await e.utils.taggedHash(ut.challenge,h,o,i)),s);if(!await st(l,i,o))throw new Error("sign: Invalid signature produced");return l},verify:st,signSync:function(t,n,r=e.utils.randomBytes()){const{m:i,px:o,d:s,rand:a}=tt(t,n,r),c=et(s,e.utils.taggedHashSync(ut.aux,a)),{R:u,rx:h,k:f}=nt(e.utils.taggedHashSync(ut.nonce,c,o,i)),l=rt(u,f,J(e.utils.taggedHashSync(ut.challenge,h,o,i)),s);if(!at(l,i,o))throw new Error("sign: Invalid signature produced");return l},verifySync:at},y.BASE._setWindowSize(8);const ct={node:h,web:"object"==typeof self&&"crypto"in self?self.crypto:void 0},ut={challenge:"BIP0340/challenge",aux:"BIP0340/aux",nonce:"BIP0340/nonce"},ht={};e.utils={isValidPrivateKey(t){try{return K(t),!0}catch(t){return!1}},privateAdd:(t,e)=>A(k(K(t)+K(e),c.n)),privateNegate:t=>{const e=K(t);return A(c.n-e)},pointAddScalar:(t,e,n)=>{const i=y.fromHex(t),o=K(e),s=y.BASE.multiplyAndAddUnsafe(i,o,r);if(!s)throw new Error("Tweaked point at infinity");return s.toRawBytes(n)},pointMultiply:(t,e,n)=>{const r=y.fromHex(t),i=I(U(e));return r.multiply(i).toRawBytes(n)},hashToPrivateKey:t=>{if((t=U(t)).length<40||t.length>1024)throw new Error("Expected 40-1024 bytes of private key as per FIPS 186");return A(k(I(t),c.n-r)+r)},randomBytes:(t=32)=>{if(ct.web)return ct.web.getRandomValues(new Uint8Array(t));if(ct.node){const{randomBytes:e}=ct.node;return Uint8Array.from(e(t))}throw new Error("The environment doesn't have randomBytes function")},randomPrivateKey:()=>e.utils.hashToPrivateKey(e.utils.randomBytes(40)),bytesToHex:v,hexToBytes:H,concatBytes:m,mod:k,invert:T,sha256:async(...t)=>{if(ct.web){const e=await ct.web.subtle.digest("SHA-256",m(...t));return new Uint8Array(e)}if(ct.node){const{createHash:e}=ct.node,n=e("sha256");return t.forEach(t=>n.update(t)),Uint8Array.from(n.digest())}throw new Error("The environment doesn't have sha256 function")},hmacSha256:async(t,...e)=>{if(ct.web){const n=await ct.web.subtle.importKey("raw",t,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]),r=m(...e),i=await ct.web.subtle.sign("HMAC",n,r);return new Uint8Array(i)}if(ct.node){const{createHmac:n}=ct.node,r=n("sha256",t);return e.forEach(t=>r.update(t)),Uint8Array.from(r.digest())}throw new Error("The environment doesn't have hmac-sha256 function")},sha256Sync:void 0,hmacSha256Sync:void 0,taggedHash:async(t,...n)=>{let r=ht[t];if(void 0===r){const n=await e.utils.sha256(Uint8Array.from(t,t=>t.charCodeAt(0)));r=m(n,n),ht[t]=r}return e.utils.sha256(r,...n)},taggedHashSync:(t,...n)=>{if("function"!=typeof e.utils.sha256Sync)throw new Error("utils.sha256Sync is undefined, you need to set it");let r=ht[t];if(void 0===r){const n=e.utils.sha256Sync(Uint8Array.from(t,t=>t.charCodeAt(0)));r=m(n,n),ht[t]=r}return e.utils.sha256Sync(r,...n)},precompute(t=8,e=y.BASE){const n=e===y.BASE?e:new y(e.x,e.y);return n._setWindowSize(t),n.multiply(o),n}}}),l=r(function(t,e){Object.defineProperty(e,"__esModule",{value:!0}),e.schnorr=e.Signature=e.Point=e.CURVE=e.utils=e.getSharedSecret=e.recoverPublicKey=e.verify=e.signSync=e.sign=e.getPublicKey=void 0;var n=f;Object.defineProperty(e,"getPublicKey",{enumerable:!0,get:function(){return n.getPublicKey}}),Object.defineProperty(e,"sign",{enumerable:!0,get:function(){return n.sign}}),Object.defineProperty(e,"signSync",{enumerable:!0,get:function(){return n.signSync}}),Object.defineProperty(e,"verify",{enumerable:!0,get:function(){return n.verify}}),Object.defineProperty(e,"recoverPublicKey",{enumerable:!0,get:function(){return n.recoverPublicKey}}),Object.defineProperty(e,"getSharedSecret",{enumerable:!0,get:function(){return n.getSharedSecret}}),Object.defineProperty(e,"utils",{enumerable:!0,get:function(){return n.utils}}),Object.defineProperty(e,"CURVE",{enumerable:!0,get:function(){return n.CURVE}}),Object.defineProperty(e,"Point",{enumerable:!0,get:function(){return n.Point}}),Object.defineProperty(e,"Signature",{enumerable:!0,get:function(){return n.Signature}}),Object.defineProperty(e,"schnorr",{enumerable:!0,get:function(){return n.schnorr}}),f.utils.hmacSha256Sync=(t,...e)=>{const n=a.hmac.create(u.sha256,t);return e.forEach(t=>n.update(t)),n.digest()}});function d(n,r){let i=t(n);return function(t,n,r,i,o){const s=Buffer.concat([e(r,32),e(i,32)],64),a=function(t,e){return t===BigInt(0)||t===BigInt(1)?t:t-BigInt(27)}(n);if(!function(t){return t===BigInt(0)||t===BigInt(1)}(a))throw new Error("Invalid signature v value");const c=l.recoverPublicKey(t,s,Number(a),!0);return Buffer.from(c).toString("base64")}(r,i.v,i.r,i.s)}function y(t){let e=t.match(/.{1,2}/g);return null===e?new Uint8Array:new Uint8Array(e.map(t=>parseInt(t,16)))}export{y as fromHexString,d as signatureToPubkey};
//# sourceMappingURL=converter.modern.js.map
