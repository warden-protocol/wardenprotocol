// @generated by protoc-gen-es v1.0.0 with parameter "rewrite_imports=./tendermint/version/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./tendermint/types/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./tendermint/crypto/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./google/api/**/*_pb.js:@buf/googleapis_googleapis.bufbuild_es,rewrite_imports=./gogoproto/**/*_pb.js:@buf/cosmos_gogo-proto.bufbuild_es,rewrite_imports=./cosmos_proto/**/*_pb.js:@buf/cosmos_cosmos-proto.bufbuild_es,rewrite_imports=./cosmos/upgrade/v1beta1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./cosmos/msg/v1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./cosmos/ics23/v1/**/*_pb.js:@buf/cosmos_ics23.bufbuild_es,rewrite_imports=./cosmos/base/v1beta1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./cosmos/base/query/v1beta1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./cosmos/auth/v1beta1/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es,rewrite_imports=./amino/**/*_pb.js:@buf/cosmos_cosmos-sdk.bufbuild_es"
// @generated from file ibc/core/channel/v1/channel.proto (package ibc.core.channel.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import { proto3 } from "@bufbuild/protobuf";
import { Height } from "../../client/v1/client_pb.js";

/**
 * State defines if a channel is in one of the following states:
 * CLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.
 *
 * @generated from enum ibc.core.channel.v1.State
 */
export const State = proto3.makeEnum(
  "ibc.core.channel.v1.State",
  [
    {no: 0, name: "STATE_UNINITIALIZED_UNSPECIFIED", localName: "UNINITIALIZED_UNSPECIFIED"},
    {no: 1, name: "STATE_INIT", localName: "INIT"},
    {no: 2, name: "STATE_TRYOPEN", localName: "TRYOPEN"},
    {no: 3, name: "STATE_OPEN", localName: "OPEN"},
    {no: 4, name: "STATE_CLOSED", localName: "CLOSED"},
  ],
);

/**
 * Order defines if a channel is ORDERED or UNORDERED
 *
 * @generated from enum ibc.core.channel.v1.Order
 */
export const Order = proto3.makeEnum(
  "ibc.core.channel.v1.Order",
  [
    {no: 0, name: "ORDER_NONE_UNSPECIFIED", localName: "NONE_UNSPECIFIED"},
    {no: 1, name: "ORDER_UNORDERED", localName: "UNORDERED"},
    {no: 2, name: "ORDER_ORDERED", localName: "ORDERED"},
  ],
);

/**
 * Channel defines pipeline for exactly-once packet delivery between specific
 * modules on separate blockchains, which has at least one end capable of
 * sending packets and one end capable of receiving packets.
 *
 * @generated from message ibc.core.channel.v1.Channel
 */
export const Channel = proto3.makeMessageType(
  "ibc.core.channel.v1.Channel",
  () => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 2, name: "ordering", kind: "enum", T: proto3.getEnumType(Order) },
    { no: 3, name: "counterparty", kind: "message", T: Counterparty },
    { no: 4, name: "connection_hops", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * IdentifiedChannel defines a channel with additional port and channel
 * identifier fields.
 *
 * @generated from message ibc.core.channel.v1.IdentifiedChannel
 */
export const IdentifiedChannel = proto3.makeMessageType(
  "ibc.core.channel.v1.IdentifiedChannel",
  () => [
    { no: 1, name: "state", kind: "enum", T: proto3.getEnumType(State) },
    { no: 2, name: "ordering", kind: "enum", T: proto3.getEnumType(Order) },
    { no: 3, name: "counterparty", kind: "message", T: Counterparty },
    { no: 4, name: "connection_hops", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 5, name: "version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Counterparty defines a channel end counterparty
 *
 * @generated from message ibc.core.channel.v1.Counterparty
 */
export const Counterparty = proto3.makeMessageType(
  "ibc.core.channel.v1.Counterparty",
  () => [
    { no: 1, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ],
);

/**
 * Packet defines a type that carries data across different chains through IBC
 *
 * @generated from message ibc.core.channel.v1.Packet
 */
export const Packet = proto3.makeMessageType(
  "ibc.core.channel.v1.Packet",
  () => [
    { no: 1, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 2, name: "source_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "source_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "destination_port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "destination_channel", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 7, name: "timeout_height", kind: "message", T: Height },
    { no: 8, name: "timeout_timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ],
);

/**
 * PacketState defines the generic type necessary to retrieve and store
 * packet commitments, acknowledgements, and receipts.
 * Caller is responsible for knowing the context necessary to interpret this
 * state as a commitment, acknowledgement, or a receipt.
 *
 * @generated from message ibc.core.channel.v1.PacketState
 */
export const PacketState = proto3.makeMessageType(
  "ibc.core.channel.v1.PacketState",
  () => [
    { no: 1, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "data", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
  ],
);

/**
 * PacketId is an identifer for a unique Packet
 * Source chains refer to packets by source port/channel
 * Destination chains refer to packets by destination port/channel
 *
 * @generated from message ibc.core.channel.v1.PacketId
 */
export const PacketId = proto3.makeMessageType(
  "ibc.core.channel.v1.PacketId",
  () => [
    { no: 1, name: "port_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "channel_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sequence", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ],
);

/**
 * Acknowledgement is the recommended acknowledgement format to be used by
 * app-specific protocols.
 * NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental
 * conflicts with other protobuf message formats used for acknowledgements.
 * The first byte of any message with this format will be the non-ASCII values
 * `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS:
 * https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
 *
 * @generated from message ibc.core.channel.v1.Acknowledgement
 */
export const Acknowledgement = proto3.makeMessageType(
  "ibc.core.channel.v1.Acknowledgement",
  () => [
    { no: 21, name: "result", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "response" },
    { no: 22, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "response" },
  ],
);

/**
 * Timeout defines an execution deadline structure for 04-channel handlers.
 * This includes packet lifecycle handlers as well as the upgrade handshake handlers.
 * A valid Timeout contains either one or both of a timestamp and block height (sequence).
 *
 * @generated from message ibc.core.channel.v1.Timeout
 */
export const Timeout = proto3.makeMessageType(
  "ibc.core.channel.v1.Timeout",
  () => [
    { no: 1, name: "height", kind: "message", T: Height },
    { no: 2, name: "timestamp", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
  ],
);

